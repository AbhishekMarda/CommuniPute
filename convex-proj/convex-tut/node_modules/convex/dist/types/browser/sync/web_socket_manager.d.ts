import { ClientMessage, ServerMessage } from "./protocol.js";
export declare type ReconnectMetadata = {
    connectionCount: number;
    lastCloseReason: string | null;
};
/**
 * A wrapper around a websocket that handles errors, reconnection, and message
 * parsing.
 */
export declare class WebSocketManager {
    private socket;
    private connectionCount;
    private lastCloseReason;
    /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */
    private readonly initialBackoff;
    /** We backoff exponentially, but we need to cap that--this is the jittered max. */
    private readonly maxBackoff;
    /** How many times have we failed consecutively? */
    private retries;
    /** How long before lack of server response causes us to initiate a reconnect,
     * in ms */
    private readonly serverInactivityThreshold;
    private reconnectDueToServerInactivityTimeout;
    private readonly uri;
    private readonly onOpen;
    private readonly onMessage;
    private readonly webSocketConstructor;
    constructor(uri: string, onOpen: (reconnectMetadata: ReconnectMetadata) => void, onMessage: (message: ServerMessage) => void, webSocketConstructor: typeof WebSocket);
    private connect;
    /**
     * @returns The state of the {@link Socket}.
     */
    socketState(): string;
    sendMessage(message: ClientMessage): void;
    private onServerActivity;
    /**
     * Close the WebSocket and schedule a reconnect when it completes closing.
     *
     * This should be used when we hit an error and would like to restart the session.
     */
    private closeAndReconnect;
    /**
     * Close the WebSocket and do not reconnect.
     * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
     */
    stop(): Promise<void>;
    pause(): Promise<void>;
    /**
     * Create a new WebSocket after a previous `pause()`, unless `stop()` was
     * called before.
     */
    resume(): Promise<void>;
    private nextBackoff;
}
//# sourceMappingURL=web_socket_manager.d.ts.map