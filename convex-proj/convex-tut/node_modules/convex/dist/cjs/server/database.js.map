{
  "version": 3,
  "sources": ["../../../src/server/database.ts"],
  "sourcesContent": ["import { GenericId } from \"../values/index.js\";\nimport {\n  DocumentByName,\n  GenericDataModel,\n  NamedTableInfo,\n  TableNamesInDataModel,\n} from \"./data_model.js\";\nimport { QueryInitializer } from \"./query.js\";\nimport {\n  WithOptionalSystemFields,\n  WithoutSystemFields,\n} from \"./system_fields.js\";\n\n/**\n * An interface to read from the database within Convex query functions.\n *\n * The two entry points are {@link DatabaseReader.get}, which fetches a single\n * document by its {@link values.GenericId}, or {@link DatabaseReader.query}, which starts\n * building a query.\n *\n * If you're using code generation, use the `DatabaseReader` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport interface DatabaseReader<DataModel extends GenericDataModel> {\n  /**\n   * Fetch a single document from the database by its {@link values.GenericId}.\n   *\n   * @param id - The {@link values.GenericId} of the document to fetch from the database.\n   * @returns - The {@link GenericDocument} of the document at the given {@link values.GenericId}, or `null` if it no longer exists.\n   */\n  get<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>\n  ): Promise<DocumentByName<DataModel, TableName> | null>;\n\n  /**\n   * Begin a query for the given table name.\n   *\n   * Queries don't execute immediately, so calling this method and extending its\n   * query are free until the results are actually used.\n   *\n   * @param tableName - The name of the table to query.\n   * @returns - A {@link QueryInitializer} object to start building a query.\n   */\n  query<TableName extends TableNamesInDataModel<DataModel>>(\n    tableName: TableName\n  ): QueryInitializer<NamedTableInfo<DataModel, TableName>>;\n}\n\n/**\n * An interface to read from and write to the database within Convex mutation\n * functions.\n *\n * Convex guarantees that all writes within a single mutation are\n * executed atomically, so you never have to worry about partial writes leaving\n * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)\n * for the guarantees Convex provides your functions.\n *\n *  If you're using code generation, use the `DatabaseReader` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport interface DatabaseWriter<DataModel extends GenericDataModel>\n  extends DatabaseReader<DataModel> {\n  /**\n   * Insert a new document into a table.\n   *\n   * @param table - The name of the table to insert a new document into.\n   * @param value - The {@link values.Value} to insert into the given table.\n   * @returns - {@link values.GenericId} of the new document.\n   */\n  insert<TableName extends TableNamesInDataModel<DataModel>>(\n    table: TableName,\n    value: WithoutSystemFields<DocumentByName<DataModel, TableName>>\n  ): Promise<GenericId<TableName>>;\n\n  /**\n   * Patch an existing document, merging its value with a new values.\n   *\n   * Any overlapping fields in the two documents will be overwritten with\n   * their new value.\n   *\n   * @param id - The {@link values.GenericId} of the document to patch.\n   * @param value - The partial {@link GenericDocument} to merge into the specified document. If this new value\n   * specifies system fields like `_id`, they must match the document's existing field values.\n   */\n  patch<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>,\n    value: Partial<DocumentByName<DataModel, TableName>>\n  ): Promise<void>;\n\n  /**\n   * Replace the value of an existing document, overwriting its old value.\n   *\n   * @param id - The {@link values.GenericId} of the document to replace.\n   * @param value - The new {@link GenericDocument} for the document. This value can omit the system fields,\n   * and the database will fill them in.\n   */\n  replace<TableName extends TableNamesInDataModel<DataModel>>(\n    id: GenericId<TableName>,\n    value: WithOptionalSystemFields<DocumentByName<DataModel, TableName>>\n  ): Promise<void>;\n\n  /**\n   * Delete an existing document.\n   *\n   * @param id - The {@link values.GenericId} of the document to remove.\n   */\n  delete(id: GenericId<TableNamesInDataModel<DataModel>>): Promise<void>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
