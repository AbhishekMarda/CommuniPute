{
  "version": 3,
  "sources": ["../../../../src/browser/sync/optimistic_updates_impl.ts"],
  "sourcesContent": ["import { Value } from \"../../values/index.js\";\nimport { createError } from \"../logging.js\";\nimport { OptimisticLocalStore } from \"./optimistic_updates.js\";\nimport { RequestId } from \"./protocol.js\";\nimport { QueryResult } from \"./remote_query_set.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\n\n/**\n * An optimistic update function that has been curried over its arguments.\n */\ntype WrappedOptimisticUpdate = (locaQueryStore: OptimisticLocalStore) => void;\n\n/**\n * The implementation of `OptimisticLocalStore`.\n *\n * This class provides the interface for optimistic updates to modify query results.\n */\nclass OptimisticLocalStoreImpl implements OptimisticLocalStore {\n  // A references of the query results in OptimisticQueryResults\n  private readonly queryResults: QueryResultsMap;\n\n  // All of the queries modified by this class\n  readonly modifiedQueries: QueryToken[];\n\n  constructor(queryResults: QueryResultsMap) {\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n\n  getQuery(name: string, args: Value[]): Value | undefined {\n    const query = this.queryResults.get(serializePathAndArgs(name, args));\n    if (query === undefined) {\n      return undefined;\n    }\n    return OptimisticLocalStoreImpl.queryValue(query.result);\n  }\n\n  getAllQueries(name: string): { args: Value[]; value: Value | undefined }[] {\n    const queriesWithName = [];\n    for (const query of this.queryResults.values()) {\n      if (query.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: query.args,\n          value: OptimisticLocalStoreImpl.queryValue(query.result),\n        });\n      }\n    }\n    return queriesWithName;\n  }\n\n  setQuery(name: string, args: Value[], value: Value | undefined): void {\n    const queryToken = serializePathAndArgs(name, args);\n\n    let result: QueryResult | undefined;\n    if (value === undefined) {\n      result = undefined;\n    } else {\n      result = {\n        success: true,\n        value,\n      };\n    }\n    const query: Query = {\n      udfPath: name,\n      args,\n      result,\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n\n  private static queryValue(\n    result: QueryResult | undefined\n  ): Value | undefined {\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      // If the query is an error state, just return `undefined` as though\n      // it's loading. Optimistic updates should already handle `undefined` well\n      // and there isn't a need to break the whole update because it tried\n      // to load a single query that errored.\n      return undefined;\n    }\n  }\n}\n\ntype OptimisticUpdateAndId = {\n  update: WrappedOptimisticUpdate;\n  mutationId: RequestId;\n};\n\ntype Query = {\n  // undefined means the query was set to be loading (undefined) in an optimistic update.\n  // Note that we can also have queries not present in the QueryResultMap\n  // at all because they are still loading from the server.\n  result: QueryResult | undefined;\n  udfPath: string;\n  args: Value[];\n};\nexport type QueryResultsMap = Map<QueryToken, Query>;\n\ntype ChangedQueries = QueryToken[];\n\n/**\n * A view of all of our query results with optimistic updates applied on top.\n */\nexport class OptimisticQueryResults {\n  private queryResults: QueryResultsMap;\n  private optimisticUpdates: OptimisticUpdateAndId[];\n\n  constructor() {\n    this.queryResults = new Map();\n    this.optimisticUpdates = [];\n  }\n\n  ingestQueryResultsFromServer(\n    serverQueryResults: QueryResultsMap,\n    optimisticUpdatesToDrop: Set<RequestId>\n  ): ChangedQueries {\n    this.optimisticUpdates = this.optimisticUpdates.filter(updateAndId => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n\n    // To find the changed queries, just do a shallow comparison\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    const changedQueries: ChangedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === undefined || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n\n    return changedQueries;\n  }\n\n  applyOptimisticUpdate(\n    update: WrappedOptimisticUpdate,\n    mutationId: RequestId\n  ): ChangedQueries {\n    // Apply the update to our store\n    this.optimisticUpdates.push({\n      update,\n      mutationId,\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n\n    // Notify about any query results that changed\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    return localStore.modifiedQueries;\n  }\n\n  queryResult(queryToken: QueryToken): Value | undefined {\n    const query = this.queryResults.get(queryToken);\n    if (query === undefined) {\n      return undefined;\n    }\n    const result = query.result;\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      throw createError(\"query\", query.udfPath, result.errorMessage);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
