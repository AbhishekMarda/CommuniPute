{
  "version": 3,
  "sources": ["../../common/temp/node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js", "../../common/temp/node_modules/.pnpm/node-fetch@2.6.7_encoding@0.1.13/node_modules/node-fetch/browser.js", "../src/browser/index.ts", "../../common/temp/node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js", "../../common/temp/node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js", "../../common/temp/node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js", "../../common/temp/node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js", "../src/index.ts", "../src/values/values.ts", "../src/browser/logging.ts", "../src/browser/sync/action_manager.ts", "../src/browser/sync/udf_path_utils.ts", "../src/browser/sync/local_state.ts", "../src/browser/sync/request_manager.ts", "../src/browser/sync/optimistic_updates_impl.ts", "../src/browser/long.ts", "../src/browser/sync/remote_query_set.ts", "../src/browser/sync/protocol.ts", "../src/browser/sync/web_socket_manager.ts", "../src/browser/sync/client.ts", "../src/common/index.ts", "../src/browser/http_client.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;", "/**\n * Tools for accessing Convex in the browser.\n *\n * **If you are using React, use the {@link react} module instead.**\n *\n * ## Usage\n *\n * Create a {@link ConvexHttpClient} to connect to the Convex Cloud.\n *\n * ```typescript\n * import { ConvexHttpClient } from \"convex/browser\";\n * // typically loaded from an environment variable\n * const address = \"https://small-mouse-123.convex.cloud\";\n * const convex = new ConvexHttpClient(address);\n * ```\n *\n * @module\n */\nexport { InternalConvexClient } from \"./sync/client.js\";\nexport type { ClientOptions } from \"./sync/client.js\";\nexport type {\n  OptimisticUpdate,\n  OptimisticLocalStore,\n} from \"./sync/optimistic_updates.js\";\nexport type { QueryResult } from \"./sync/remote_query_set.js\";\nexport type { QueryToken } from \"./sync/udf_path_utils.js\";\nexport { ConvexHttpClient } from \"./http_client.js\";\nexport type { Query, Mutation } from \"./http_client.js\";\nexport * from \"../api/index.js\";\nexport type { QueryJournal } from \"./sync/protocol.js\";\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "export const version = \"0.9.1\";\n", "/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"base64-js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * **Important**: Use `myId.equals(otherId)` to check for equality.\n * Using `===` will not work because two different instances of `Id` can refer\n * to the same document.\n *\n * `Id`s are 17 bytes long and consist of:\n * - A 15-byte random value.\n * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.\n * This is encoded in base 62 ([0-9A-Za-z]).\n *\n * If you're using code generation, use the `Id` class typed for your data model in\n * `convex/_generated/dataModel.js`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport class Id<TableName extends string> {\n  /**\n   * The table name this {@link GenericId} references.\n   */\n  public readonly tableName: TableName;\n\n  /**\n   * The identifier string.\n   *\n   * This contains the characters `[0-9A-Za-z]`.\n   */\n  public readonly id: string;\n\n  constructor(tableName: TableName, id: string) {\n    this.tableName = tableName;\n    this.id = id;\n  }\n\n  /**\n   * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.\n   *\n   * @param other - The other {@link GenericId} to compare to.\n   * @returns `true` if the objects refer to the same document.\n   */\n  equals(other: unknown): boolean {\n    if (other instanceof Id) {\n      return this.tableName === other.tableName && this.id === other.id;\n    }\n    return false;\n  }\n\n  /**\n   * Parse a {@link GenericId} from its JSON representation.\n   */\n  static fromJSON(obj: any): Id<string> {\n    if (typeof obj.$id !== \"string\") {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`\n      );\n    }\n    const parts = obj.$id.split(\"|\");\n    if (parts.length !== 2) {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`\n      );\n    }\n    return new Id(parts[0], parts[1]);\n  }\n\n  /**\n   * Convert a {@link GenericId} into its JSON representation.\n   */\n  toJSON(): JSONValue {\n    const idString = `${this.tableName}|${this.id}`;\n    return { $id: idString };\n  }\n\n  /**\n   * Convert a {@link GenericId} into its string representation.\n   *\n   * This includes the identifier but not the table name.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Pretty-print this {@link GenericId} for debugging.\n   */\n  inspect(): string {\n    return `Id('${this.tableName}', '${this.id}')`;\n  }\n}\n\n/**\n * Internal type used in Convex code generation.\n *\n * @public\n */\nexport type GenericIdConstructor<TableNames extends string> = {\n  new <TableName extends TableNames>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName>;\n  prototype: Id<string>;\n  fromJSON(obj: any): Id<string>;\n};\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | Id<string>\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | Set<Value>\n  | Map<Value, Value>\n  | { [key: string]: Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 64;\nconst ALL_UNDERSCORES = /^_+$/;\nconst IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;\n\nfunction validateObjectField(k: string) {\n  if (k.length === 0) {\n    throw new Error(\"Empty field names are disallowed.\");\n  }\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  if (ALL_UNDERSCORES.test(k)) {\n    throw new Error(`Field name ${k} can't exclusively be underscores.`);\n  }\n  if (!IDENTIFIER_REGEX.test(k)) {\n    throw new Error(\n      `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`\n    );\n  }\n}\n\nfunction jsonToConvexInternal(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof Array) {\n    return value.map(jsonToConvexInternal);\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$id\" || key === \"$weakRef\" || key === \"$strongRef\") {\n      return Id.fromJSON(value);\n    }\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      if (!(value.$set instanceof Array)) {\n        throw new Error(`Malformed $set field on ${value}`);\n      }\n      return new Set(value.$set.map(jsonToConvexInternal));\n    }\n    if (key === \"$map\") {\n      if (!(value.$map instanceof Array)) {\n        throw new Error(`Malformed $map field on ${value}`);\n      }\n      const map = new Map();\n      for (const pair of value.$map) {\n        if (!(pair instanceof Array) || pair.length !== 2) {\n          throw new Error(`Malformed pair in $map ${value}`);\n        }\n        const k = jsonToConvexInternal(pair[0]);\n        const v = jsonToConvexInternal(pair[1]);\n        map.set(k, v);\n      }\n      return map;\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvexInternal(v);\n  }\n  return out;\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will revive classes like {@link GenericId} that have been serialized to JSON, parse out `BigInt`s, and so on.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  return jsonToConvexInternal(value);\n}\n\nfunction stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` will serialize `undefined` to `null` which\n      // produces a confusing error message. Use `\"undefined\"` instead.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (value instanceof Id) {\n    return value.toJSON();\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (value instanceof Array) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`)\n    );\n  }\n  if (value instanceof Set) {\n    return {\n      $set: [...value].map((value, i) =>\n        convexToJsonInternal(value, originalValue, context + `.keys()[${i}]`)\n      ),\n    };\n  }\n  if (value instanceof Map) {\n    return {\n      $map: [...value].map(([k, v], i) => {\n        const jsonKey = convexToJsonInternal(\n          k,\n          originalValue,\n          context + `.keys()[${i}]`\n        );\n        const jsonValue = convexToJsonInternal(\n          v,\n          originalValue,\n          context + `.values()[${i}]`\n        );\n        return [jsonKey, jsonValue];\n      }),\n    };\n  }\n\n  if (typeof value !== \"object\") {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype) {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);\n  }\n  return out;\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\");\n}\n", "// This is blue #9 from https://www.radix-ui.com/docs/colors/palette-composition/the-scales\n// It must look good in both light and dark mode.\nconst INFO_COLOR = \"color:rgb(0, 145, 255)\";\n\nexport type UdfType = \"query\" | \"mutation\" | \"action\";\n\nfunction prefix_for_source(source: UdfType) {\n  switch (source) {\n    case \"query\":\n      return \"Q\";\n    case \"mutation\":\n      return \"M\";\n    case \"action\":\n      return \"A\";\n  }\n}\n\nexport function logToConsole(\n  type: \"info\" | \"error\",\n  source: UdfType,\n  udfPath: string,\n  message: string\n) {\n  const prefix = prefix_for_source(source);\n  if (type === \"info\") {\n    console.log(`%c[CONVEX ${prefix}(${udfPath})] ${message}`, INFO_COLOR);\n  } else {\n    console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);\n  }\n}\n\nexport function logFatalError(message: string): Error {\n  const errorMessage = `[CONVEX FATAL ERROR] ${message}`;\n  console.error(errorMessage);\n  return new Error(errorMessage);\n}\n\nexport function createError(\n  source: UdfType,\n  udfPath: string,\n  message: string\n): Error {\n  const prefix = prefix_for_source(source);\n  return new Error(`[CONVEX ${prefix}(${udfPath})] ${message}`);\n}\n", "import { ActionRequest, ActionResponse, RequestId } from \"./protocol.js\";\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { createError, logToConsole } from \"../logging.js\";\n\ntype ActionStatus = {\n  message: ActionRequest;\n  onResult: (result: any) => void;\n  onFailure: (reason: any) => void;\n};\n\nexport class ActionManager {\n  private inflightActions: Map<RequestId, ActionStatus>;\n\n  constructor() {\n    this.inflightActions = new Map();\n  }\n\n  request(message: ActionRequest): Promise<any> {\n    const result = new Promise((resolve, reject) => {\n      this.inflightActions.set(message.requestId, {\n        message,\n        onResult: resolve,\n        onFailure: reject,\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a action response.\n   */\n  onResponse(response: ActionResponse) {\n    const actionInfo = this.inflightActions.get(response.requestId);\n    if (actionInfo === undefined) {\n      // Got a response of a message that we don't know about. That shouldn't\n      // really happen unless we get duplicate messages or something.\n      return;\n    }\n\n    this.inflightActions.delete(response.requestId);\n    const udfPath = actionInfo.message.udfPath;\n    for (const line of response.logLines) {\n      logToConsole(\"info\", \"action\", udfPath, line);\n    }\n    if (response.success) {\n      actionInfo.onResult(jsonToConvex(response.result));\n    } else {\n      logToConsole(\"error\", \"action\", udfPath, response.result);\n      actionInfo.onFailure(createError(\"action\", udfPath, response.result));\n    }\n  }\n\n  hasInflightActions(): boolean {\n    return this.inflightActions.size > 0;\n  }\n\n  restart() {\n    // Unlike mutations, actions are not idempotent. When we reconnect to the\n    // backend, we don't know if it is safe to resend in-flight actions, so we\n    // cancel them and consider them failed.\n    // TODO(presley): If we make the server remember it has started executing a\n    // function, we can resend here and remove browser to backend connectivity as\n    // a source of transient errors. For example, if a function has never reached\n    // the server, then we can safely execute it. If a function was executed\n    // successfully but response didn't reach the client. Server can return\n    // success on reconnect.\n    for (const [actionId, actionInfo] of this.inflightActions) {\n      this.inflightActions.delete(actionId);\n      const udfPath = actionInfo.message.udfPath;\n      actionInfo.onFailure(createError(\"action\", udfPath, \"Transient error\"));\n    }\n  }\n}\n", "import { convexToJson } from \"../../values/index.js\";\n\nexport function canonicalizeUdfPath(udfPath: string): string {\n  const pieces = udfPath.split(\":\");\n  let moduleName: string;\n  let functionName: string;\n  if (pieces.length === 1) {\n    moduleName = pieces[0];\n    functionName = \"default\";\n  } else {\n    moduleName = pieces.slice(0, pieces.length - 1).join(\":\");\n    functionName = pieces[pieces.length - 1];\n  }\n  if (!moduleName.endsWith(\".js\")) {\n    moduleName = `${moduleName}.js`;\n  }\n  return `${moduleName}:${functionName}`;\n}\n\n/**\n * A string representing the name and arguments of a query.\n *\n * This is used by the {@link InternalConvexClient}.\n *\n * @public\n */\nexport type QueryToken = string;\n\n// TODO(CX-749): Make this a unique representation (sort sets, dicts, objects)\nexport function serializePathAndArgs(udfPath: string, args: any[]): QueryToken {\n  return JSON.stringify({\n    udfPath: canonicalizeUdfPath(udfPath),\n    args: convexToJson(args),\n  });\n}\n", "import { convexToJson } from \"../../values/index.js\";\nimport {\n  AddQuery,\n  RemoveQuery,\n  QueryId,\n  QuerySetModification,\n  QuerySetVersion,\n  IdentityVersion,\n  Authenticate,\n  QueryJournal,\n  Transition,\n} from \"./protocol.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\n\ntype LocalQuery = {\n  id: QueryId;\n  canonicalizedUdfPath: string;\n  args: any[];\n  numSubscribers: number;\n  journal?: QueryJournal;\n};\n\nexport class LocalSyncState {\n  private nextQueryId: QueryId;\n  private querySetVersion: QuerySetVersion;\n  private readonly querySet: Map<QueryToken, LocalQuery>;\n  private readonly queryIdToToken: Map<QueryId, QueryToken>;\n  private identityVersion: IdentityVersion;\n  private auth?: { tokenType: \"Admin\" | \"User\"; value: string };\n\n  constructor() {\n    this.nextQueryId = 0;\n    this.querySetVersion = 0;\n    this.identityVersion = 0;\n    this.querySet = new Map();\n    this.queryIdToToken = new Map();\n  }\n\n  subscribe(\n    udfPath: string,\n    args: any[],\n    journal?: QueryJournal\n  ): {\n    queryToken: QueryToken;\n    modification: QuerySetModification | null;\n    unsubscribe: () => QuerySetModification | null;\n  } {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n\n    const existingEntry = this.querySet.get(queryToken);\n\n    if (existingEntry !== undefined) {\n      existingEntry.numSubscribers += 1;\n      return {\n        queryToken,\n        modification: null,\n        unsubscribe: () => this.removeSubscriber(queryToken),\n      };\n    } else {\n      const queryId = this.nextQueryId++;\n      const query: LocalQuery = {\n        id: queryId,\n        canonicalizedUdfPath,\n        args,\n        numSubscribers: 1,\n        journal,\n      };\n      this.querySet.set(queryToken, query);\n      this.queryIdToToken.set(queryId, queryToken);\n\n      const baseVersion = this.querySetVersion;\n      const newVersion = ++this.querySetVersion;\n\n      const add: AddQuery = {\n        type: \"Add\",\n        queryId,\n        udfPath: canonicalizedUdfPath,\n        args: args.map(convexToJson),\n        journal,\n      };\n      const modification: QuerySetModification = {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [add],\n      };\n      return {\n        queryToken,\n        modification,\n        unsubscribe: () => this.removeSubscriber(queryToken),\n      };\n    }\n  }\n\n  saveQueryJournals(transition: Transition) {\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\":\n        case \"QueryFailed\": {\n          const journal = modification.journal;\n          if (journal !== undefined) {\n            const queryToken = this.queryIdToToken.get(modification.queryId);\n            // We may have already unsubscribed to this query by the time the server\n            // sends us the journal. If so, just ignore it.\n            if (queryToken !== undefined) {\n              this.querySet.get(queryToken)!.journal = journal;\n            }\n          }\n\n          break;\n        }\n        case \"QueryRemoved\": {\n          break;\n        }\n        default: {\n          // Enforce that the switch-case is exhaustive.\n          const _: never = modification;\n          throw new Error(`Invalid modification ${modification}`);\n        }\n      }\n    }\n  }\n\n  queryId(udfPath: string, args: any[]): QueryId | null {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n    const existingEntry = this.querySet.get(queryToken);\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n    return null;\n  }\n\n  setAuth(value: string): Authenticate {\n    this.auth = {\n      tokenType: \"User\",\n      value: value,\n    };\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      baseVersion: baseVersion,\n      ...this.auth,\n    };\n  }\n\n  setAdminAuth(value: string): Authenticate {\n    this.auth = {\n      tokenType: \"Admin\",\n      value: value,\n    };\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      baseVersion: baseVersion,\n      ...this.auth,\n    };\n  }\n\n  clearAuth(): Authenticate {\n    this.auth = undefined;\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      tokenType: \"None\",\n      baseVersion: baseVersion,\n    };\n  }\n\n  hasAuth(): boolean {\n    return !!this.auth;\n  }\n\n  isNewAuth(value: string): boolean {\n    return this.auth?.value !== value;\n  }\n\n  queryPath(queryId: QueryId): string | null {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs)!.canonicalizedUdfPath;\n    }\n    return null;\n  }\n\n  queryArgs(queryId: QueryId): any[] | null {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs)!.args;\n    }\n    return null;\n  }\n\n  queryToken(queryId: QueryId): string | null {\n    return this.queryIdToToken.get(queryId) ?? null;\n  }\n\n  queryJournal(queryToken: QueryToken): QueryJournal | undefined {\n    return this.querySet.get(queryToken)?.journal;\n  }\n\n  restart(): [QuerySetModification, Authenticate?] {\n    const modifications = [];\n    for (const localQuery of this.querySet.values()) {\n      const add: AddQuery = {\n        type: \"Add\",\n        queryId: localQuery.id,\n        udfPath: localQuery.canonicalizedUdfPath,\n        args: localQuery.args.map(convexToJson),\n        journal: localQuery.journal,\n      };\n      modifications.push(add);\n    }\n    this.querySetVersion = 1;\n    const querySet: QuerySetModification = {\n      type: \"ModifyQuerySet\",\n      baseVersion: 0,\n      newVersion: 1,\n      modifications,\n    };\n    // If there's no auth, no need to send an update as the server will also start with an unknown identity.\n    if (!this.auth) {\n      this.identityVersion = 0;\n      return [querySet, undefined];\n    }\n    const authenticate: Authenticate = {\n      type: \"Authenticate\",\n      baseVersion: 0,\n      ...this.auth,\n    };\n    this.identityVersion = 1;\n    return [querySet, authenticate];\n  }\n\n  private removeSubscriber(\n    queryToken: QueryToken\n  ): QuerySetModification | null {\n    const localQuery = this.querySet.get(queryToken)!;\n\n    if (localQuery.numSubscribers > 1) {\n      localQuery.numSubscribers -= 1;\n      return null;\n    } else {\n      this.querySet.delete(queryToken);\n      this.queryIdToToken.delete(localQuery.id);\n      const baseVersion = this.querySetVersion;\n      const newVersion = ++this.querySetVersion;\n      const remove: RemoveQuery = {\n        type: \"Remove\",\n        queryId: localQuery.id,\n      };\n      return {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [remove],\n      };\n    }\n  }\n}\n", "import { jsonToConvex } from \"../../values/index.js\";\nimport { createError, logToConsole } from \"../logging.js\";\nimport { Long } from \"../long.js\";\nimport {\n  ClientMessage,\n  MutationRequest,\n  MutationResponse,\n  RequestId,\n} from \"./protocol.js\";\n\ntype RequestStatus =\n  | {\n      status: \"Requested\";\n      onResult: (result: any) => void;\n      onFailure: (reason: any) => void;\n    }\n  | {\n      status: \"Completed\";\n      onResolve: () => void;\n      ts: Long;\n    };\n\n// RequestManager tracks idempotent requests - Mutations.\nexport class RequestManager {\n  private inflightRequests: Map<\n    RequestId,\n    {\n      message: MutationRequest;\n      status: RequestStatus;\n    }\n  >;\n  constructor() {\n    this.inflightRequests = new Map();\n  }\n\n  request(message: MutationRequest): Promise<any> {\n    const result = new Promise((resolve, reject) => {\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: { status: \"Requested\", onResult: resolve, onFailure: reject },\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise. Only applies to mutations.\n   */\n  onResponse(response: MutationResponse): RequestId | null {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === undefined) {\n      // Annoyingly we can occasionally get responses to mutations that we're no\n      // longer tracking. One flow where this happens is:\n      // 1. Client sends mutation 1\n      // 2. Client gets response for mutation 1. The sever says that it was committed at ts=10.\n      // 3. Client is disconnected\n      // 4. Client reconnects and re-issues queries and this mutation.\n      // 5. Server sends transition message to ts=20\n      // 6. Client drops mutation because it's already been observed.\n      // 7. Client receives a second response for mutation 1 but doesn't know about it anymore.\n\n      // The right fix for this is probably to add a reconciliation phase on\n      // reconnection where we receive responses to all the mutations before\n      // the transition message so this flow could never happen (CX-1513).\n\n      // For now though, we can just ignore this message.\n      return null;\n    }\n\n    // Because `.restart()` re-requests completed requests, we may get some\n    // responses for requests that are already in the \"Completed\" state.\n    // We can safely ignore those because we've already notified the UI about\n    // their results.\n    if (requestInfo.status.status !== \"Requested\") {\n      return null;\n    }\n\n    const udfType = \"mutation\";\n    const udfPath = requestInfo.message.udfPath;\n\n    for (const line of response.logLines) {\n      logToConsole(\"info\", udfType, udfPath, line);\n    }\n\n    const status = requestInfo.status;\n    let onResolve;\n    if (response.success) {\n      onResolve = () => status.onResult(jsonToConvex(response.result));\n    } else {\n      logToConsole(\"error\", udfType, udfPath, response.result);\n      onResolve = () =>\n        status.onFailure(createError(udfType, udfPath, response.result));\n    }\n\n    if (!response.success) {\n      // We can resolve Mutation failures immediately since they don't have any\n      // side effects.\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      return response.requestId;\n    }\n\n    // We have to wait to resolve the request promise until after we transition\n    // past this timestamp so clients can read their own writes.\n    requestInfo.status = {\n      status: \"Completed\",\n      ts: response.ts,\n      onResolve,\n    };\n\n    return null;\n  }\n\n  // Removed completed requests and returns the set of completed\n  // mutations.\n  removeCompleted(ts: Long): Set<RequestId> {\n    const completeMutations: Set<RequestId> = new Set();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        if (requestInfo.message.type === \"Mutation\") {\n          completeMutations.add(requestId);\n        }\n        this.inflightRequests.delete(requestId);\n      }\n    }\n    return completeMutations;\n  }\n\n  restart(): ClientMessage[] {\n    // When we reconnect to the backend, re-request all the in-flight requests.\n\n    // This includes ones that have already been completed because we still\n    // want to tell the backend to transition the client past the completed\n    // timestamp. This is safe because mutations are idempotent.\n    const allMessages = [];\n    for (const value of this.inflightRequests.values()) {\n      allMessages.push(value.message);\n    }\n    return allMessages;\n  }\n\n  /**\n   ** @returns true if there are any requests that have been requested but have\n   ** not be completed yet.\n   **/\n  hasIncompleteRequests(): boolean {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   ** @returns true if there are any inflight requests, including ones that have\n   ** completed on the server, but have not been applied.\n   **/\n  hasInflightRequests(): boolean {\n    return this.inflightRequests.size > 0;\n  }\n}\n", "import { Value } from \"../../values/index.js\";\nimport { createError } from \"../logging.js\";\nimport { OptimisticLocalStore } from \"./optimistic_updates.js\";\nimport { RequestId } from \"./protocol.js\";\nimport { QueryResult } from \"./remote_query_set.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\n\n/**\n * An optimistic update function that has been curried over its arguments.\n */\ntype WrappedOptimisticUpdate = (locaQueryStore: OptimisticLocalStore) => void;\n\n/**\n * The implementation of `OptimisticLocalStore`.\n *\n * This class provides the interface for optimistic updates to modify query results.\n */\nclass OptimisticLocalStoreImpl implements OptimisticLocalStore {\n  // A references of the query results in OptimisticQueryResults\n  private readonly queryResults: QueryResultsMap;\n\n  // All of the queries modified by this class\n  readonly modifiedQueries: QueryToken[];\n\n  constructor(queryResults: QueryResultsMap) {\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n\n  getQuery(name: string, args: Value[]): Value | undefined {\n    const query = this.queryResults.get(serializePathAndArgs(name, args));\n    if (query === undefined) {\n      return undefined;\n    }\n    return OptimisticLocalStoreImpl.queryValue(query.result);\n  }\n\n  getAllQueries(name: string): { args: Value[]; value: Value | undefined }[] {\n    const queriesWithName = [];\n    for (const query of this.queryResults.values()) {\n      if (query.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: query.args,\n          value: OptimisticLocalStoreImpl.queryValue(query.result),\n        });\n      }\n    }\n    return queriesWithName;\n  }\n\n  setQuery(name: string, args: Value[], value: Value | undefined): void {\n    const queryToken = serializePathAndArgs(name, args);\n\n    let result: QueryResult | undefined;\n    if (value === undefined) {\n      result = undefined;\n    } else {\n      result = {\n        success: true,\n        value,\n      };\n    }\n    const query: Query = {\n      udfPath: name,\n      args,\n      result,\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n\n  private static queryValue(\n    result: QueryResult | undefined\n  ): Value | undefined {\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      // If the query is an error state, just return `undefined` as though\n      // it's loading. Optimistic updates should already handle `undefined` well\n      // and there isn't a need to break the whole update because it tried\n      // to load a single query that errored.\n      return undefined;\n    }\n  }\n}\n\ntype OptimisticUpdateAndId = {\n  update: WrappedOptimisticUpdate;\n  mutationId: RequestId;\n};\n\ntype Query = {\n  // undefined means the query was set to be loading (undefined) in an optimistic update.\n  // Note that we can also have queries not present in the QueryResultMap\n  // at all because they are still loading from the server.\n  result: QueryResult | undefined;\n  udfPath: string;\n  args: Value[];\n};\nexport type QueryResultsMap = Map<QueryToken, Query>;\n\ntype ChangedQueries = QueryToken[];\n\n/**\n * A view of all of our query results with optimistic updates applied on top.\n */\nexport class OptimisticQueryResults {\n  private queryResults: QueryResultsMap;\n  private optimisticUpdates: OptimisticUpdateAndId[];\n\n  constructor() {\n    this.queryResults = new Map();\n    this.optimisticUpdates = [];\n  }\n\n  ingestQueryResultsFromServer(\n    serverQueryResults: QueryResultsMap,\n    optimisticUpdatesToDrop: Set<RequestId>\n  ): ChangedQueries {\n    this.optimisticUpdates = this.optimisticUpdates.filter(updateAndId => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n\n    // To find the changed queries, just do a shallow comparison\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    const changedQueries: ChangedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === undefined || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n\n    return changedQueries;\n  }\n\n  applyOptimisticUpdate(\n    update: WrappedOptimisticUpdate,\n    mutationId: RequestId\n  ): ChangedQueries {\n    // Apply the update to our store\n    this.optimisticUpdates.push({\n      update,\n      mutationId,\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n\n    // Notify about any query results that changed\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    return localStore.modifiedQueries;\n  }\n\n  queryResult(queryToken: QueryToken): Value | undefined {\n    const query = this.queryResults.get(queryToken);\n    if (query === undefined) {\n      return undefined;\n    }\n    const result = query.result;\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      throw createError(\"query\", query.udfPath, result.errorMessage);\n    }\n  }\n}\n", "// Implements an unsigned long.\n// This is a subset of https://github.com/dcodeIO/Long.js\n// `| 0` assures the runtime that we are using integer arithmetic\n\n// This works... but don't try to compare one to a real Long.js Long!\n// For internal use only.\nexport class Long {\n  low: number;\n  high: number;\n  __isUnsignedLong__: boolean;\n\n  static isLong(obj: Long) {\n    return (obj && obj.__isUnsignedLong__) === true;\n  }\n\n  constructor(low: number, high: number) {\n    this.low = low | 0;\n    this.high = high | 0;\n    this.__isUnsignedLong__ = true;\n  }\n\n  // prettier-ignore\n  static fromBytesLE(bytes: number[]): Long {\n    return new Long(\n      bytes[0] |\n      bytes[1] << 8 |\n      bytes[2] << 16 |\n      bytes[3] << 24,\n      bytes[4] |\n      bytes[5] << 8 |\n      bytes[6] << 16 |\n      bytes[7] << 24,\n    );\n  }\n\n  // prettier-ignore\n  toBytesLE() {\n    const hi = this.high;\n    const lo = this.low;\n    return [\n      lo & 0xff,\n      lo >>> 8 & 0xff,\n      lo >>> 16 & 0xff,\n      lo >>> 24,\n      hi & 0xff,\n      hi >>> 8 & 0xff,\n      hi >>> 16 & 0xff,\n      hi >>> 24\n    ];\n  }\n\n  static fromNumber(value: number) {\n    if (isNaN(value)) return UZERO;\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    return new Long(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0);\n  }\n\n  equals(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  }\n\n  notEquals(other: Long) {\n    return !this.equals(other);\n  }\n\n  comp(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.equals(other)) return 0;\n    return other.high >>> 0 > this.high >>> 0 ||\n      (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n      ? -1\n      : 1;\n  }\n\n  lessThanOrEqual(other: Long) {\n    return this.comp(/* validates */ other) <= 0;\n  }\n\n  static fromValue(val: any) {\n    if (typeof val === \"number\") return Long.fromNumber(val);\n    // Throws for non-objects, converts non-instanceof Long:\n    return new Long(val.low, val.high);\n  }\n}\n\nconst UZERO = new Long(0, 0);\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst MAX_UNSIGNED_VALUE = new Long(0xffffffff | 0, 0xffffffff | 0);\n", "import { jsonToConvex, Value } from \"../../values/index.js\";\nimport { Long } from \"../long.js\";\nimport { logToConsole } from \"../logging.js\";\nimport { QueryId, StateVersion, Transition } from \"./protocol.js\";\n\n/**\n * The result of running a query function on the server.\n *\n * If the function hit an exception it will have an `errorMessage`. Otherwise\n * it will produce a `Value`.\n *\n * @public\n */\nexport type QueryResult =\n  | {\n      success: true;\n      value: Value;\n    }\n  | { success: false; errorMessage: string };\n\n/**\n * A represention of the query results we've received on the current WebSocket\n * connection.\n */\nexport class RemoteQuerySet {\n  private version: StateVersion;\n  private readonly remoteQuerySet: Map<QueryId, QueryResult>;\n  private readonly queryPath: (queryId: QueryId) => string | null;\n\n  constructor(queryPath: (queryId: QueryId) => string | null) {\n    this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };\n    this.remoteQuerySet = new Map();\n    this.queryPath = queryPath;\n  }\n\n  transition(transition: Transition): void {\n    const start = transition.startVersion;\n    if (\n      this.version.querySet !== start.querySet ||\n      this.version.ts.notEquals(start.ts) ||\n      this.version.identity !== start.identity\n    ) {\n      throw new Error(`Invalid start version: ${start.ts}:${start.querySet}`);\n    }\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logToConsole(\"info\", \"query\", queryPath, line);\n            }\n          }\n          const value = jsonToConvex(modification.value ?? null);\n          this.remoteQuerySet.set(modification.queryId, {\n            success: true,\n            value,\n          });\n          break;\n        }\n        case \"QueryFailed\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logToConsole(\"info\", \"query\", queryPath, line);\n            }\n          }\n\n          this.remoteQuerySet.set(modification.queryId, {\n            success: false,\n            errorMessage: modification.errorMessage,\n          });\n          break;\n        }\n        case \"QueryRemoved\": {\n          this.remoteQuerySet.delete(modification.queryId);\n          break;\n        }\n        default: {\n          // Enforce that the switch-case is exhaustive.\n          const _: never = modification;\n          throw new Error(`Invalid modification ${modification}`);\n        }\n      }\n    }\n    this.version = transition.endVersion;\n  }\n\n  remoteQueryResults(): Map<QueryId, QueryResult> {\n    return this.remoteQuerySet;\n  }\n\n  timestamp(): Long {\n    return this.version.ts;\n  }\n}\n", "import * as Base64 from \"base64-js\";\nimport { JSONValue } from \"../../values/index.js\";\nimport { Long } from \"../long.js\";\n\n/**\n * Shared schema\n */\n\nexport function u64ToLong(encoded: EncodedU64): U64 {\n  const integerBytes = Base64.toByteArray(encoded);\n  return Long.fromBytesLE(Array.from(integerBytes));\n}\n\nexport function parseServerMessage(\n  encoded: EncodedServerMessage\n): ServerMessage {\n  switch (encoded.type) {\n    case \"FatalError\":\n    case \"AuthError\":\n    case \"ActionResponse\":\n    case \"Ping\": {\n      return { ...encoded };\n    }\n    case \"MutationResponse\": {\n      if (encoded.success) {\n        return { ...encoded, ts: u64ToLong(encoded.ts) };\n      } else {\n        return { ...encoded };\n      }\n    }\n    case \"Transition\": {\n      return {\n        ...encoded,\n        startVersion: {\n          ...encoded.startVersion,\n          ts: u64ToLong(encoded.startVersion.ts),\n        },\n        endVersion: {\n          ...encoded.endVersion,\n          ts: u64ToLong(encoded.endVersion.ts),\n        },\n      };\n    }\n    default: {\n      const _exhaustivenessCheck: never = encoded;\n    }\n  }\n  return undefined as never;\n}\n\ntype U64 = Long;\ntype EncodedU64 = string;\n\n/**\n * Unique nonnegative integer identifying a single query.\n */\nexport type QueryId = number; // nonnegative int\n\nexport type QuerySetVersion = number; // nonnegative int\n\nexport type RequestId = number; // nonnegative int\n\nexport type IdentityVersion = number; // nonnegative int\n\n/**\n * A serialized representation of decisions made during a query's execution.\n *\n * A journal is produced when a query function first executes and is re-used\n * when a query is re-executed.\n *\n * Currently this is used to store pagination end cursors to ensure\n * that pages of paginated queries will always end at the same cursor. This\n * enables gapless, reactive pagination.\n *\n * `null` is used to represent empty journals.\n * @public\n */\nexport type QueryJournal = string | null;\n\n/**\n * Client message schema\n */\n\ntype Connect = {\n  type: \"Connect\";\n  sessionId: string;\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\nexport type AddQuery = {\n  type: \"Add\";\n  queryId: QueryId;\n  udfPath: string;\n  args: JSONValue[];\n  journal?: QueryJournal;\n};\n\nexport type RemoveQuery = {\n  type: \"Remove\";\n  queryId: QueryId;\n};\n\nexport type QuerySetModification = {\n  type: \"ModifyQuerySet\";\n  baseVersion: QuerySetVersion;\n  newVersion: QuerySetVersion;\n  modifications: (AddQuery | RemoveQuery)[];\n};\n\nexport type MutationRequest = {\n  type: \"Mutation\";\n  requestId: RequestId;\n  udfPath: string;\n  args: JSONValue[];\n};\n\nexport type ActionRequest = {\n  type: \"Action\";\n  requestId: RequestId;\n  udfPath: string;\n  args: JSONValue[];\n};\n\nexport type Authenticate =\n  | {\n      type: \"Authenticate\";\n      tokenType: \"Admin\";\n      value: string;\n      baseVersion: IdentityVersion;\n    }\n  | {\n      type: \"Authenticate\";\n      tokenType: \"User\";\n      value: string;\n      baseVersion: IdentityVersion;\n    }\n  | {\n      type: \"Authenticate\";\n      tokenType: \"None\";\n      baseVersion: IdentityVersion;\n    };\nexport type ClientMessage =\n  | Connect\n  | Authenticate\n  | QuerySetModification\n  | MutationRequest\n  | ActionRequest;\n\n/**\n * Server message schema\n */\ntype TS = U64;\ntype EncodedTS = EncodedU64;\ntype LogLines = string[];\n\nexport type StateVersion = {\n  querySet: QueryId;\n  ts: TS;\n  identity: IdentityVersion;\n};\ntype EncodedStateVersion = Omit<StateVersion, \"ts\"> & { ts: EncodedTS };\n\ntype StateModification =\n  | {\n      type: \"QueryUpdated\";\n      queryId: QueryId;\n      value: JSONValue;\n      logLines: LogLines;\n      // Optional because old backend versions don't send this.\n      journal?: QueryJournal;\n    }\n  | {\n      type: \"QueryFailed\";\n      queryId: QueryId;\n      errorMessage: string;\n      logLines: LogLines;\n      // Optional because old backend versions don't send this.\n      journal?: QueryJournal;\n    }\n  | {\n      type: \"QueryRemoved\";\n      queryId: QueryId;\n    };\n\nexport type Transition = {\n  type: \"Transition\";\n  startVersion: StateVersion;\n  endVersion: StateVersion;\n  modifications: StateModification[];\n};\n\ntype MutationSuccess = {\n  type: \"MutationResponse\";\n  requestId: RequestId;\n  success: true;\n  result: JSONValue;\n  ts: TS;\n  logLines: LogLines;\n};\ntype MutationFailed = {\n  type: \"MutationResponse\";\n  requestId: RequestId;\n  success: false;\n  result: string;\n  logLines: LogLines;\n};\nexport type MutationResponse = MutationSuccess | MutationFailed;\ntype ActionSuccess = {\n  type: \"ActionResponse\";\n  requestId: RequestId;\n  success: true;\n  result: JSONValue;\n  logLines: LogLines;\n};\ntype ActionFailed = {\n  type: \"ActionResponse\";\n  requestId: RequestId;\n  success: false;\n  result: string;\n  logLines: LogLines;\n};\nexport type ActionResponse = ActionSuccess | ActionFailed;\nexport type AuthError = {\n  type: \"AuthError\";\n  error: string;\n};\ntype FatalError = {\n  type: \"FatalError\";\n  error: string;\n};\ntype Ping = {\n  type: \"Ping\";\n};\n\nexport type ServerMessage =\n  | Transition\n  | MutationResponse\n  | ActionResponse\n  | FatalError\n  | AuthError\n  | Ping;\n\ntype EncodedTransition = Omit<Transition, \"startVersion\" | \"endVersion\"> & {\n  startVersion: EncodedStateVersion;\n  endVersion: EncodedStateVersion;\n};\ntype EncodedMutationSuccess = Omit<MutationSuccess, \"ts\"> & { ts: EncodedTS };\ntype EncodedMutationResponse = MutationFailed | EncodedMutationSuccess;\n\ntype EncodedServerMessage =\n  | EncodedTransition\n  | EncodedMutationResponse\n  | ActionResponse\n  | FatalError\n  | AuthError\n  | Ping;\n", "import {\n  ClientMessage,\n  parseServerMessage,\n  ServerMessage,\n} from \"./protocol.js\";\n\nconst CLOSE_NORMAL = 1000;\nconst CLOSE_NO_STATUS = 1005;\n\ntype PromisePair<T> = { promise: Promise<T>; resolve: (value: T) => void };\n\n/**\n * The various states our WebSocket can be in:\n *\n * - \"disconnected\": We don't have a WebSocket, but plan to create one.\n * - \"connecting\": We have created the WebSocket and are waiting for the\n *   `onOpen` callback.\n * - \"ready\": We have an open WebSocket.\n * - \"closing\": We called `.close()` on the WebSocket and are waiting for the\n *   `onClose` callback before we schedule a reconnect.\n * - \"stopping\": The application decided to totally stop the WebSocket. We are\n *    waiting for the `onClose` callback before we consider this WebSocket stopped.\n * - \"pausing\": The client needs to fetch some data before it makes sense to resume\n *    the WebSocket connection.\n * - \"paused\": The WebSocket was stopped and a new one can be created via `.resume()`.\n * - \"stopped\": We have stopped the WebSocket and will never create a new one.\n *\n *\n * WebSocket State Machine\n * -----------------------\n * initialState: disconnected\n * validTransitions:\n *   disconnected:\n *     new WebSocket() -> connecting\n *     stop() -> stopped\n *   connecting:\n *     onopen -> ready\n *     close() -> closing\n *     stop() -> stopping\n *   ready:\n *     close() -> closing\n *     pause() -> pausing\n *     stop() -> stopping\n *   closing:\n *     onclose -> disconnected\n *     stop() -> stopping\n *   pausing:\n *     onclose -> paused\n *     stop() -> stopping\n *   paused:\n *     resume() -> connecting\n *     stop() -> stopped\n *   stopping:\n *     onclose -> stopped\n * terminalStates:\n *   stopped\n */\ntype Socket =\n  | { state: \"disconnected\" }\n  | { state: \"connecting\"; ws: WebSocket }\n  | { state: \"ready\"; ws: WebSocket }\n  | { state: \"closing\" }\n  | { state: \"pausing\"; promisePair: PromisePair<null> }\n  | { state: \"paused\" }\n  | { state: \"stopping\"; promisePair: PromisePair<null> }\n  | { state: \"stopped\" };\n\nfunction promisePair<T>(): PromisePair<T> {\n  let resolvePromise: (value: T) => void;\n  const promise = new Promise<T>(resolve => {\n    resolvePromise = resolve;\n  });\n  return { promise, resolve: resolvePromise! };\n}\n\nexport type ReconnectMetadata = {\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\n/**\n * A wrapper around a websocket that handles errors, reconnection, and message\n * parsing.\n */\nexport class WebSocketManager {\n  private socket: Socket;\n\n  private connectionCount: number;\n  private lastCloseReason: string | null;\n\n  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n  private readonly initialBackoff: number;\n\n  /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n  private readonly maxBackoff: number;\n\n  /** How many times have we failed consecutively? */\n  private retries: number;\n\n  /** How long before lack of server response causes us to initiate a reconnect,\n   * in ms */\n  private readonly serverInactivityThreshold: number;\n\n  private reconnectDueToServerInactivityTimeout: ReturnType<\n    typeof setTimeout\n  > | null;\n\n  private readonly uri: string;\n  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n  private readonly onMessage: (message: ServerMessage) => void;\n  private readonly webSocketConstructor: typeof WebSocket;\n\n  constructor(\n    uri: string,\n    onOpen: (reconnectMetadata: ReconnectMetadata) => void,\n    onMessage: (message: ServerMessage) => void,\n    webSocketConstructor: typeof WebSocket\n  ) {\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n\n    this.initialBackoff = 100;\n    this.maxBackoff = 16000;\n    this.retries = 0;\n\n    this.serverInactivityThreshold = 30000;\n    this.reconnectDueToServerInactivityTimeout = null;\n\n    this.uri = uri;\n    this.onOpen = onOpen;\n    this.onMessage = onMessage;\n\n    // Kick off connection but don't wait for it.\n    void this.connect();\n  }\n\n  private async connect() {\n    if (\n      this.socket.state === \"closing\" ||\n      this.socket.state === \"stopping\" ||\n      this.socket.state === \"stopped\"\n    ) {\n      return;\n    }\n    if (\n      this.socket.state !== \"disconnected\" &&\n      this.socket.state !== \"paused\"\n    ) {\n      throw new Error(\"Didn't start connection from disconnected state\");\n    }\n\n    const ws = new this.webSocketConstructor(this.uri);\n    this.socket = {\n      state: \"connecting\",\n      ws,\n    };\n    ws.onopen = () => {\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = { state: \"ready\", ws };\n      this.onServerActivity();\n      this.onOpen({\n        connectionCount: this.connectionCount,\n        lastCloseReason: this.lastCloseReason,\n      });\n\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.\n    ws.onerror = error => {\n      const message = (error as ErrorEvent).message;\n      console.log(`WebSocket error: ${message}`);\n      this.closeAndReconnect(\"WebSocketError\");\n    };\n    ws.onmessage = message => {\n      // TODO(CX-1498): We reset the retry counter on any successful message.\n      // This is not ideal and we should improve this further.\n      this.retries = 0;\n      this.onServerActivity();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this.onMessage(serverMessage);\n    };\n    ws.onclose = event => {\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_NO_STATUS) {\n        let msg = `WebSocket closed unexpectedly with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.error(msg);\n      }\n      if (this.socket.state === \"stopping\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"stopped\" };\n        return;\n      }\n      if (this.socket.state === \"pausing\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"paused\" };\n        return;\n      }\n      this.socket = { state: \"disconnected\" };\n      const backoff = this.nextBackoff();\n      console.log(`Attempting reconnect in ${backoff}ms`);\n      setTimeout(() => this.connect(), backoff);\n    };\n  }\n\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState(): string {\n    return this.socket.state;\n  }\n\n  sendMessage(message: ClientMessage) {\n    if (this.socket.state === \"ready\") {\n      const request = JSON.stringify(message);\n      try {\n        this.socket.ws.send(request);\n      } catch (error: any) {\n        console.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n    }\n  }\n\n  private onServerActivity() {\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n\n  /**\n   * Close the WebSocket and schedule a reconnect when it completes closing.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  private closeAndReconnect(closeReason: string) {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"closing\":\n      case \"stopping\":\n      case \"stopped\":\n      case \"pausing\":\n      case \"paused\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.lastCloseReason = closeReason;\n        this.socket.ws.close();\n        this.socket = {\n          state: \"closing\",\n        };\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  async stop(): Promise<void> {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"stopped\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"pausing\":\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"stopping\" so we don't reconnect.\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"paused\":\n      case \"disconnected\":\n        // If we're disconnected so switch the state to \"stopped\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        // If we're paused prevent a resume.\n        this.socket = { state: \"stopped\" };\n        return;\n      case \"stopping\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  async pause(): Promise<void> {\n    switch (this.socket.state) {\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore pause\n        return;\n      case \"paused\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"pausing\" so we don't reconnect.\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"disconnected\":\n        // We're disconnected so switch the state to \"paused\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        this.socket = { state: \"paused\" };\n        return;\n      case \"pausing\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Create a new WebSocket after a previous `pause()`, unless `stop()` was\n   * called before.\n   */\n  async resume(): Promise<void> {\n    switch (this.socket.state) {\n      case \"pausing\":\n      case \"paused\":\n        break;\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore resume\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"closing\":\n      case \"disconnected\":\n        throw new Error(\"`resume()` is only valid after `pause()`\");\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    if (this.socket.state === \"pausing\") {\n      await this.socket.promisePair.promise;\n    }\n    await this.connect();\n  }\n\n  private nextBackoff(): number {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}\n", "import { v4 as uuidv4 } from \"uuid\";\nimport { GenericAPI } from \"../../api/index.js\";\nimport { version } from \"../../index.js\";\nimport { convexToJson, JSONValue, Value } from \"../../values/index.js\";\nimport { logFatalError } from \"../logging.js\";\nimport { ActionManager } from \"./action_manager.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport {\n  OptimisticLocalStore,\n  OptimisticUpdate,\n} from \"./optimistic_updates.js\";\nimport {\n  OptimisticQueryResults,\n  QueryResultsMap,\n} from \"./optimistic_updates_impl.js\";\nimport {\n  ActionRequest,\n  AuthError,\n  MutationRequest,\n  QueryId,\n  QueryJournal,\n  RequestId,\n  ServerMessage,\n} from \"./protocol.js\";\nimport { QueryResult, RemoteQuerySet } from \"./remote_query_set.js\";\nimport { QueryToken, serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { ReconnectMetadata, WebSocketManager } from \"./web_socket_manager.js\";\n\n/**\n * Options for {@link InternalConvexClient}.\n *\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * Whether to prompt the user if they have unsaved changes pending\n   * when navigating away or closing a web page.\n   *\n   * This is only possible when the `window` object exists, i.e. in a browser.\n   *\n   * The default value is `true`.\n   */\n  unsavedChangesWarning?: boolean;\n  /**\n   * Specifies an alternate\n   * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n   * constructor to use for client communication with the Convex cloud.\n   * The default behavior is to use `WebSocket` from the global environment.\n   */\n  webSocketConstructor?: typeof WebSocket;\n}\n\n/**\n * State describing the client's connection with the Convex backend.\n *\n * @public\n */\nexport type ConnectionState = {\n  hasInflightRequests: boolean;\n  isWebSocketConnected: boolean;\n};\n\n/**\n * An async function returning the JWT-encoded OpenID Connect Identity Token\n * if available.\n * See {@link ConvexReactClient.setAuth}.\n *\n * @public\n */\nexport type AuthTokenFetcher = () => Promise<string | null | undefined>;\n\nconst DEFAULT_OPTIONS = {\n  unsavedChangesWarning: true,\n};\n\n/**\n * Low-level client for directly integrating state management libraries\n * with Convex.\n *\n * Most developers should use higher level clients, like\n * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.\n *\n * @public\n */\nexport class InternalConvexClient {\n  private readonly state: LocalSyncState;\n  private readonly requestManager: RequestManager;\n  private readonly actionManager: ActionManager;\n  private readonly webSocketManager: WebSocketManager;\n  private remoteQuerySet: RemoteQuerySet;\n  private readonly optimisticQueryResults: OptimisticQueryResults;\n  private readonly onTransition: (updatedQueries: QueryToken[]) => void;\n  private nextRequestId: RequestId;\n  private readonly sessionId: string;\n  private fetchToken: null | (() => Promise<string | null | undefined>) = null;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed.\n   * @param options - See {@link ClientOptions} for a full description.\n   */\n  constructor(\n    address: string,\n    onTransition: (updatedQueries: QueryToken[]) => void,\n    options?: ClientOptions\n  ) {\n    if (typeof address === \"object\") {\n      throw new Error(\n        \"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\"\n      );\n    }\n    options = { ...DEFAULT_OPTIONS, ...options };\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\n        \"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\"\n      );\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n\n    // Substitute http(s) with ws(s)\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3); // move past the double slash\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet(queryId =>\n      this.state.queryPath(queryId)\n    );\n    this.requestManager = new RequestManager();\n    this.actionManager = new ActionManager();\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.onTransition = onTransition;\n    this.nextRequestId = 0;\n    this.sessionId = uuidv4();\n\n    const { unsavedChangesWarning } = options;\n    if (typeof window === \"undefined\" && unsavedChangesWarning) {\n      throw new Error(\n        \"unsavedChangesWarning enabled, but no window object found! Navigating away from the page could cause in-flight mutations to be dropped. Pass {unsavedChangesWarning: false} in Convex client options to disable this feature.\"\n      );\n    }\n\n    // Listen for tab close events and notify the user on unsaved changes.\n    unsavedChangesWarning &&\n      window.addEventListener(\"beforeunload\", e => {\n        if (\n          this.requestManager.hasIncompleteRequests() ||\n          this.actionManager.hasInflightActions()\n        ) {\n          // There are 3 different ways to trigger this pop up so just try all of\n          // them.\n\n          e.preventDefault();\n          // This confirmation message doesn't actually appear in most modern\n          // browsers but we tried.\n          const confirmationMessage =\n            \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n\n    this.webSocketManager = new WebSocketManager(\n      wsUri,\n      (reconnectMetadata: ReconnectMetadata) => {\n        // We have a new WebSocket!\n\n        this.webSocketManager.sendMessage({\n          ...reconnectMetadata,\n          type: \"Connect\",\n          sessionId: this.sessionId,\n        });\n\n        // Throw out our remote query, reissue queries\n        // and outstanding mutations, and reauthenticate.\n        this.remoteQuerySet = new RemoteQuerySet(queryId =>\n          this.state.queryPath(queryId)\n        );\n        const [querySetModification, authModification] = this.state.restart();\n        if (authModification) {\n          this.webSocketManager.sendMessage(authModification);\n        }\n        this.webSocketManager.sendMessage(querySetModification);\n        this.actionManager.restart();\n        for (const message of this.requestManager.restart()) {\n          this.webSocketManager.sendMessage(message);\n        }\n      },\n      (serverMessage: ServerMessage) => {\n        switch (serverMessage.type) {\n          case \"Transition\": {\n            this.remoteQuerySet.transition(serverMessage);\n            this.state.saveQueryJournals(serverMessage);\n            // No optimistic updates for workflows.\n            const completedMutations = this.requestManager.removeCompleted(\n              this.remoteQuerySet.timestamp()\n            );\n            this.notifyOnQueryResultChanges(completedMutations);\n            break;\n          }\n          case \"MutationResponse\": {\n            const completedMutationId =\n              this.requestManager.onResponse(serverMessage);\n            if (completedMutationId) {\n              this.notifyOnQueryResultChanges(new Set([completedMutationId]));\n            }\n            break;\n          }\n          case \"ActionResponse\": {\n            this.actionManager.onResponse(serverMessage);\n            break;\n          }\n          case \"AuthError\": {\n            this.tryToReauthenticate(serverMessage)\n              .then()\n              .catch(error => {\n                logFatalError(error);\n                // TODO(CX-3070): This ignores a failed Promise\n                void this.webSocketManager.stop();\n              });\n            break;\n          }\n          case \"FatalError\": {\n            const error = logFatalError(serverMessage.error);\n            void this.webSocketManager.stop();\n            throw error;\n          }\n          case \"Ping\":\n            break; // do nothing\n          default: {\n            const _typeCheck: never = serverMessage;\n          }\n        }\n      },\n      webSocketConstructor\n    );\n  }\n\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  private notifyOnQueryResultChanges(completedMutations: Set<RequestId>) {\n    const remoteQueryResults: Map<QueryId, QueryResult> =\n      this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue: QueryResultsMap = new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      // It's possible that we've already unsubscribed to this query but\n      // the server hasn't learned about that yet. If so, ignore this one.\n\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId)!,\n          args: this.state.queryArgs(queryId)!,\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n\n    this.onTransition(\n      this.optimisticQueryResults.ingestQueryResultsFromServer(\n        queryTokenToValue,\n        completedMutations\n      )\n    );\n  }\n\n  async setAuth(fetchToken: AuthTokenFetcher) {\n    this.fetchToken = fetchToken;\n    const token = await fetchToken();\n    if (token) {\n      this.authenticate(token);\n    } else if (this.state.hasAuth()) {\n      this.clearAuth();\n    }\n  }\n\n  // Stop the webSocket so that we don't retry with bad auth\n  private async tryToReauthenticate(serverMessage: AuthError) {\n    if (!this.fetchToken) {\n      throw new Error(serverMessage.error);\n    }\n    console.log(\"Attempting to reauthenticate\");\n    await this.webSocketManager.pause();\n    const token = await this.fetchToken();\n    if (token && this.state.isNewAuth(token)) {\n      this.state.setAuth(token);\n    } else if (this.state.hasAuth()) {\n      console.log(\"Reauthentication failed, clearing auth\");\n      this.state.clearAuth();\n    }\n    await this.webSocketManager.resume();\n  }\n\n  private authenticate(token: string) {\n    const message = this.state.setAuth(token);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /** @internal */\n  setAdminAuth(value: string) {\n    const message = this.state.setAdminAuth(value);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /**\n   * Subscribe to a query function.\n   *\n   * Whenever this query's result changes, the `onTransition` callback\n   * passed into the constructor will be called.\n   *\n   * @param name - The name of the query.\n   * @param args - An array of the arguments to the query.\n   * @param journal - An (optional) journal produced from a previous\n   * execution of this query function. Note that if this query function with\n   * these arguments has already been requested the journal will have no effect.\n   * @returns An object containing a {@link QueryToken} corresponding to this\n   * query and an `unsubscribe` callback.\n   */\n  subscribe(\n    name: string,\n    args: any[],\n    journal?: QueryJournal\n  ): { queryToken: QueryToken; unsubscribe: () => void } {\n    // `subscribe` used to collect the arguments with a rest operator\n    // (like `...args`). Double check that it's an array to make sure developers\n    // have updated their code.\n    if (!Array.isArray(args)) {\n      throw new Error(\n        `Query arguments to \\`InternalConvexClient.subcribe\\` must be an array. Received ${args}.`\n      );\n    }\n\n    const { modification, queryToken, unsubscribe } = this.state.subscribe(\n      name,\n      args,\n      journal\n    );\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    // TODO: Use FinalizationRegistry?\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification = unsubscribe();\n        if (modification) {\n          this.webSocketManager.sendMessage(modification);\n        }\n      },\n    };\n  }\n\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(udfPath: string, args: any[]): Value | undefined {\n    const queryToken = serializePathAndArgs(udfPath, args);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - An array of arguments to this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(name: string, args: any[]): QueryJournal | undefined {\n    const queryToken = serializePathAndArgs(name, args);\n    return this.state.queryJournal(queryToken);\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return {\n      hasInflightRequests:\n        this.requestManager.hasInflightRequests() ||\n        this.actionManager.hasInflightActions(),\n      isWebSocketConnected: this.webSocketManager.socketState() === \"ready\",\n    };\n  }\n\n  async mutate<Args extends any[]>(\n    udfPath: string,\n    args: Args,\n    optimisticUpdate: OptimisticUpdate<GenericAPI, Args> | null = null\n  ): Promise<any> {\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n\n    if (optimisticUpdate !== null) {\n      const wrappedUpdate = (localQueryStore: OptimisticLocalStore) => {\n        optimisticUpdate(localQueryStore, ...args);\n      };\n      const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(\n        wrappedUpdate,\n        requestId\n      );\n      this.onTransition(changedQueries);\n    }\n\n    const message: MutationRequest = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      args: convexToJson(args) as JSONValue[],\n    };\n    const result = this.requestManager.request(message);\n    this.webSocketManager.sendMessage(message);\n    return result;\n  }\n\n  async action<Args extends any[]>(udfPath: string, args: Args): Promise<any> {\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n\n    const message: ActionRequest = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      args: convexToJson(args) as JSONValue[],\n    };\n\n    const result = this.actionManager.request(message);\n    this.webSocketManager.sendMessage(message);\n    return result;\n  }\n\n  async close(): Promise<void> {\n    return this.webSocketManager.stop();\n  }\n}\n", "export const STATUS_CODE_OK = 200;\n\nexport const STATUS_CODE_BAD_REQUEST = 400;\n\n// Special custom 5xx HTTP status code to mean that the UDF returned an error.\n//\n// Must match constant of the same name in Rust.\nexport const STATUS_CODE_UDF_FAILED = 560;\n", "import {\n  ActionNames,\n  GenericAPI,\n  MutationNames,\n  NamedAction,\n  NamedMutation,\n  NamedQuery,\n  QueryNames,\n} from \"../api/index.js\";\nimport { STATUS_CODE_UDF_FAILED } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport { convexToJson, jsonToConvex } from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\n\n/** In browsers, Node.js 18, Deno, etc. `fetch` is a global function */\ntype WindowFetch = typeof window.fetch;\n\nconst fetch: WindowFetch =\n  globalThis.fetch ||\n  ((...args) =>\n    import(\"node-fetch\").then(({ default: fetch }) =>\n      (fetch as unknown as WindowFetch)(...args)\n    ));\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex query function on the server.\n *\n * @public\n */\nexport interface Query<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the query on the server, returning a `Promise` of the return value.\n   *\n   * @param args - Arguments for the query.\n   * @returns The result of the query.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface Mutation<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex action on the server.\n *\n * @internal\n */\nexport interface Action<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the action on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the action.\n   * @returns The return value of the server-side action call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n *\n * @public\n */\nexport class ConvexHttpClient<API extends GenericAPI> {\n  private readonly address: string;\n  private auth?: string;\n  private debug: boolean;\n  constructor(address: string) {\n    this.address = `${address}/api`;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.auth = value;\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Construct a new {@link Query}.\n   *\n   * @param name - The name of the query function.\n   * @returns The {@link Query} object with that name.\n   */\n  query<Name extends QueryNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedQuery<API, Name>>\n    ): Promise<ReturnType<NamedQuery<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/query`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedQuery<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Mutation}.\n   *\n   * @param name - The name of the mutation function.\n   * @returns The {@link Mutation} object with that name.\n   */\n  mutation<Name extends MutationNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedMutation<API, Name>>\n    ): Promise<ReturnType<NamedMutation<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/mutation`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedMutation<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Action}.\n   *\n   * @param name - The name of the action.\n   * @returns The {@link Action} object with that name.\n   * @public\n   */\n  action<Name extends ActionNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedAction<API, Name>>\n    ): Promise<ReturnType<NamedAction<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/action`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedAction<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["toByteArray", "fromByteArray", "len", "i", "len2", "value", "Base64", "modification", "fetch"]
}
