{
  "version": 3,
  "sources": ["../../../../src/cli/lib/config.ts"],
  "sourcesContent": ["import chalk from \"chalk\";\nimport axios from \"axios\";\nimport equal from \"deep-equal\";\nimport path from \"path\";\nimport {\n  Bundle,\n  bundle,\n  databaseEntryPoints,\n  actionsEntryPoints,\n  actionsDir,\n} from \"../../bundler/index.js\";\nimport { version } from \"../../index.js\";\nimport axiosRetry from \"axios-retry\";\nimport {\n  deprecationCheckWarning,\n  formatSize,\n  functionsDir,\n  fatalServerErr,\n} from \"./utils.js\";\nexport { provisionHost, productionProvisionHost } from \"./utils.js\";\nimport { Context } from \"./context.js\";\n\n/** Type representing auth configuration. */\nexport interface AuthInfo {\n  // Provider-specific application identifier. Corresponds to the `aud` field in an OIDC token.\n  applicationID: string;\n  // Domain used for authentication. Corresponds to the `iss` field in an OIDC token.\n  domain: string;\n}\n\n/** Type representing Convex project configuration. */\nexport interface ProjectConfig {\n  project: string;\n  team: string;\n  prodUrl: string;\n  functions: string;\n  authInfo: AuthInfo[];\n}\n\nexport interface Config {\n  projectConfig: ProjectConfig;\n  modules: Bundle[];\n  udfServerVersion?: string;\n}\n\n/** Check if object is of AuthInfo type. */\nfunction isAuthInfo(object: any): object is AuthInfo {\n  return (\n    \"applicationID\" in object &&\n    typeof object.applicationID === \"string\" &&\n    \"domain\" in object &&\n    typeof object.domain === \"string\"\n  );\n}\n\nfunction isAuthInfos(object: any): object is AuthInfo[] {\n  return Array.isArray(object) && object.every((item: any) => isAuthInfo(item));\n}\n\n/** Error parsing ProjectConfig representation. */\nclass ParseError extends Error {}\n\n/** Parse object to ProjectConfig. */\nexport function parseProjectConfig(obj: any): ProjectConfig {\n  if (typeof obj !== \"object\") {\n    throw new ParseError(\"Expected an object\");\n  }\n  if (typeof obj.team !== \"string\") {\n    if (obj.instanceName && obj.origin) {\n      // This is likely a convex.json generated 0.1.8 or older.\n      throw new ParseError(\n        'If upgrading from convex 0.1.8 or below, please delete \"convex.json\" and reinitialize using `npx convex reinit`'\n      );\n    }\n    throw new ParseError(\"Expected team to be a string\");\n  }\n  if (typeof obj.project !== \"string\") {\n    throw new ParseError(\"Expected project to be a string\");\n  }\n  if (typeof obj.prodUrl !== \"string\") {\n    throw new ParseError(\"Expected prodUrl to be a string\");\n  }\n  if (typeof obj.functions !== \"string\") {\n    throw new ParseError(\"Expected functions to be a string\");\n  }\n\n  // Allow the `authInfo` key to be omitted, treating it as an empty list of providers.\n  obj.authInfo = obj.authInfo ?? [];\n  if (!isAuthInfos(obj.authInfo)) {\n    throw new ParseError(\"Expected authInfo to be type AuthInfo[]\");\n  }\n\n  // Important! We return the object itself (not a new object) because\n  // we want to ensure that fields we're unaware of are \"passed through\".\n  // It's possible that this is an old client and the server knows about new\n  // fields that we don't.\n  return obj;\n}\n\n/** Parse a deployment config returned by the backend. */\nfunction parseBackendConfig(obj: any): {\n  functions: string;\n  authInfo: AuthInfo[];\n} {\n  if (typeof obj !== \"object\") {\n    throw new ParseError(\"Expected an object\");\n  }\n  if (typeof obj.functions !== \"string\") {\n    throw new ParseError(\"Expected functions to be a string\");\n  }\n\n  // Allow the `authInfo` key to be omitted, treating it as an empty list of providers.\n  obj.authInfo = obj.authInfo ?? [];\n  if (!isAuthInfos(obj.authInfo)) {\n    throw new ParseError(\"Expected authInfo to be type AuthInfo[]\");\n  }\n\n  // Important! We return the object itself (not a new object) because\n  // we want to ensure that fields we're unaware of are \"passed through\".\n  // It's possible that this is an old client and the server knows about new\n  // fields that we don't.\n  return obj;\n}\n\nexport function configName(): string {\n  return \"convex.json\";\n}\n\nexport async function configFilepath(ctx: Context): Promise<string> {\n  const configFn = configName();\n  // We used to allow src/convex.json, but no longer (as of 10/7/2022).\n  // Leave an error message around to help people out. We can remove this\n  // error message after a couple months.\n  const preferredLocation = configFn;\n  const wrongLocation = path.join(\"src\", configFn);\n\n  // Allow either location, but not both.\n  const preferredLocationExists = ctx.fs.exists(preferredLocation);\n  const wrongLocationExists = ctx.fs.exists(wrongLocation);\n  if (preferredLocationExists && wrongLocationExists) {\n    console.error(\n      chalk.red(\n        `Error: both ${preferredLocation} and ${wrongLocation} files exist!`\n      )\n    );\n    console.error(`Consolidate these and remove ${wrongLocation}.`);\n    return await ctx.fatalError(1, \"fs\");\n  }\n  if (!preferredLocationExists && wrongLocationExists) {\n    console.error(\n      chalk.red(\n        `Error: Please move ${wrongLocation} to the root of your project`\n      )\n    );\n    return await ctx.fatalError(1, \"fs\");\n  }\n\n  return preferredLocation;\n}\n\n/** Read configuration from a local `convex.json` file. */\nexport async function readProjectConfig(ctx: Context): Promise<{\n  projectConfig: ProjectConfig;\n  configPath: string;\n}> {\n  let projectConfig;\n  const configPath = await configFilepath(ctx);\n  try {\n    projectConfig = parseProjectConfig(\n      JSON.parse(ctx.fs.readUtf8File(configPath))\n    );\n  } catch (err) {\n    if (err instanceof ParseError || err instanceof SyntaxError) {\n      console.error(chalk.red(`Error: Parsing \"${configPath}\" failed`));\n      console.error(chalk.gray(err.toString()));\n    } else {\n      console.error(\n        chalk.red(`Error: Unable to read project config file \"${configPath}\"`)\n      );\n      console.error(\n        \"Are you running this command from the root directory of a Convex project?\"\n      );\n      if (err instanceof Error) {\n        console.error(chalk.gray(err.message));\n      }\n    }\n    return await ctx.fatalError(1, \"fs\", err);\n  }\n  return {\n    projectConfig,\n    configPath,\n  };\n}\n\n/**\n * Given an {@link ProjectConfig}, add in the bundled modules to produce the\n * complete config.\n */\nexport async function configFromProjectConfig(\n  ctx: Context,\n  projectConfig: ProjectConfig,\n  configPath: string,\n  verbose: boolean\n): Promise<Config> {\n  let modules;\n  try {\n    const baseDir = functionsDir(configPath, projectConfig);\n    // We bundle functions entry points separately since they execute on different\n    // platforms.\n    const entryPoints = await databaseEntryPoints(ctx.fs, baseDir, verbose);\n    modules = await bundle(ctx.fs, baseDir, entryPoints, true, \"browser\");\n    if (verbose) {\n      console.log(\n        \"Queries and mutations modules: \",\n        modules.map(m => m.path)\n      );\n    }\n\n    // Bundle actions.\n    const nodeEntryPoints = await actionsEntryPoints(ctx.fs, baseDir, verbose);\n    const nodeModules = await bundle(\n      ctx.fs,\n      baseDir,\n      nodeEntryPoints,\n      true,\n      \"node\",\n      path.join(actionsDir, \"_deps\")\n    );\n    if (verbose) {\n      console.log(\n        \"Actions modules: \",\n        nodeModules.map(m => m.path)\n      );\n    }\n    modules.push(...nodeModules);\n  } catch (err) {\n    console.error(chalk.red(\"Error: Unable to bundle Convex modules\"));\n    if (err instanceof Error) {\n      console.error(chalk.gray(err.message));\n    }\n    return await ctx.fatalError(1, \"fs\", err);\n  }\n\n  return {\n    projectConfig: projectConfig,\n    modules: modules,\n    // We're just using the version this CLI is running with for now.\n    // This could be different than the version of `convex` the app runs with\n    // if the CLI is installed globally.\n    udfServerVersion: version,\n  };\n}\n\n/**\n * Read the config from `convex.json` and bundle all the modules.\n */\nexport async function readConfig(\n  ctx: Context,\n  verbose: boolean\n): Promise<{ config: Config; configPath: string }> {\n  const { projectConfig, configPath } = await readProjectConfig(ctx);\n  const config = await configFromProjectConfig(\n    ctx,\n    projectConfig,\n    configPath,\n    verbose\n  );\n  return { config, configPath };\n}\n\n/** Write the config to `convex.json` in the current working directory. */\nexport async function writeProjectConfig(\n  ctx: Context,\n  projectConfig: ProjectConfig\n) {\n  const configPath = await configFilepath(ctx);\n  try {\n    const contents = JSON.stringify(projectConfig, undefined, 2) + \"\\n\";\n    ctx.fs.writeUtf8File(configPath, contents, 0o644);\n  } catch (err) {\n    console.error(\n      chalk.red(\n        `Error: Unable to write project config file \"${configPath}\" in current directory`\n      )\n    );\n    console.error(\n      \"Are you running this command from the root directory of a Convex project?\"\n    );\n    return await ctx.fatalError(1, \"fs\", err);\n  }\n  ctx.fs.mkdir(functionsDir(configPath, projectConfig), {\n    allowExisting: true,\n  });\n}\n\n/** Pull configuration from the given remote origin. */\nexport async function pullConfig(\n  ctx: Context,\n  project: string,\n  team: string,\n  origin: string,\n  adminKey: string\n): Promise<Config> {\n  const client = axios.create();\n  axiosRetry(client, {\n    retries: 4,\n    retryDelay: axiosRetry.exponentialDelay,\n    retryCondition: error => {\n      return error.response?.status === 404 || false;\n    },\n  });\n  try {\n    const res = await client.post(\n      `${origin}/api/${version}/get_config`,\n      { version, adminKey },\n      {\n        maxContentLength: Infinity,\n      }\n    );\n    deprecationCheckWarning(ctx, res);\n    const { functions, authInfo } = parseBackendConfig(res.data.config);\n    const projectConfig = {\n      project,\n      team,\n      prodUrl: origin,\n      functions,\n      authInfo,\n    };\n    return {\n      projectConfig,\n      modules: res.data.modules,\n      udfServerVersion: res.data.udfServerVersion,\n    };\n  } catch (err) {\n    console.error(\n      chalk.red(\"Error: Unable to pull deployment config from\", origin)\n    );\n    return await fatalServerErr(ctx, err);\n  }\n}\n\nexport function configJSON(config: Config, adminKey: string) {\n  // Override origin with the url\n  const projectConfig = {\n    projectSlug: config.projectConfig.project,\n    teamSlug: config.projectConfig.team,\n    functions: config.projectConfig.functions,\n    authInfo: config.projectConfig.authInfo,\n  };\n  return {\n    config: projectConfig,\n    modules: config.modules,\n    udfServerVersion: config.udfServerVersion,\n    adminKey,\n  };\n}\n\n/** Push configuration to the given remote origin. */\nexport async function pushConfig(\n  ctx: Context,\n  config: Config,\n  adminKey: string,\n  url: string\n): Promise<void> {\n  const serializedConfig = configJSON(config, adminKey);\n  try {\n    await axios.post(`${url}/api/${version}/push_config`, serializedConfig, {\n      maxContentLength: Infinity,\n      maxBodyLength: Infinity,\n    });\n  } catch (err) {\n    console.error(chalk.red(\"Error: Unable to push deployment config to\", url));\n    return await fatalServerErr(ctx, err);\n  }\n}\n\ntype Files = { source: string; filename: string }[];\n\nexport type CodegenResponse =\n  | {\n      success: true;\n      files: Files;\n    }\n  | {\n      success: false;\n      error: string;\n    };\n\nfunction renderModule(module: Bundle): string {\n  const sourceMapSize = formatSize(module.sourceMap?.length ?? 0);\n  return (\n    module.path +\n    ` (${formatSize(module.source.length)}, source map ${sourceMapSize})`\n  );\n}\n\nfunction compareModules(oldModules: Bundle[], newModules: Bundle[]): string {\n  let diff = \"\";\n\n  const droppedModules = [];\n  for (const oldModule of oldModules) {\n    let matches = false;\n    for (const newModule of newModules) {\n      if (\n        oldModule.path === newModule.path &&\n        oldModule.source === newModule.source &&\n        oldModule.sourceMap === newModule.sourceMap\n      ) {\n        matches = true;\n        break;\n      }\n    }\n    if (!matches) {\n      droppedModules.push(oldModule);\n    }\n  }\n  if (droppedModules.length > 0) {\n    diff += \"Delete the following modules:\\n\";\n    for (const module of droppedModules) {\n      diff += \"[-] \" + renderModule(module) + \"\\n\";\n    }\n  }\n\n  const addedModules = [];\n  for (const newModule of newModules) {\n    let matches = false;\n    for (const oldModule of oldModules) {\n      if (\n        oldModule.path === newModule.path &&\n        oldModule.source === newModule.source &&\n        oldModule.sourceMap === newModule.sourceMap\n      ) {\n        matches = true;\n        break;\n      }\n    }\n    if (!matches) {\n      addedModules.push(newModule);\n    }\n  }\n  if (addedModules.length > 0) {\n    diff += \"Add the following modules:\\n\";\n    for (const module of addedModules) {\n      diff += \"[+] \" + renderModule(module) + \"\\n\";\n    }\n  }\n\n  return diff;\n}\n\n/** Generate a human-readable diff between the two configs. */\nexport function diffConfig(oldConfig: Config, newConfig: Config): string {\n  let diff = compareModules(oldConfig.modules, newConfig.modules);\n\n  const droppedAuth = [];\n  for (const oldAuth of oldConfig.projectConfig.authInfo) {\n    let matches = false;\n    for (const newAuth of newConfig.projectConfig.authInfo) {\n      if (equal(oldAuth, newAuth)) {\n        matches = true;\n        break;\n      }\n    }\n    if (!matches) {\n      droppedAuth.push(oldAuth);\n    }\n  }\n  if (droppedAuth.length > 0) {\n    diff += \"Remove the following auth providers:\\n\";\n    for (const authInfo of droppedAuth) {\n      diff += \"[-] \" + JSON.stringify(authInfo) + \"\\n\";\n    }\n  }\n\n  const addedAuth = [];\n  for (const newAuth of newConfig.projectConfig.authInfo) {\n    let matches = false;\n    for (const oldAuth of oldConfig.projectConfig.authInfo) {\n      if (equal(newAuth, oldAuth)) {\n        matches = true;\n        break;\n      }\n    }\n    if (!matches) {\n      addedAuth.push(newAuth);\n    }\n  }\n  if (addedAuth.length > 0) {\n    diff += \"Add the following auth providers:\\n\";\n    for (const auth of addedAuth) {\n      diff += \"[+] \" + JSON.stringify(auth) + \"\\n\";\n    }\n  }\n\n  let versionMessage = \"\";\n  const matches = oldConfig.udfServerVersion === newConfig.udfServerVersion;\n  if (oldConfig.udfServerVersion && (!newConfig.udfServerVersion || !matches)) {\n    versionMessage += `[-] ${oldConfig.udfServerVersion}\\n`;\n  }\n  if (newConfig.udfServerVersion && (!oldConfig.udfServerVersion || !matches)) {\n    versionMessage += `[+] ${newConfig.udfServerVersion}\\n`;\n  }\n  if (versionMessage) {\n    diff += \"Change the server's function version:\\n\";\n    diff += versionMessage;\n  }\n\n  return diff;\n}\n"],
  "mappings": "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",
  "names": ["matches"]
}
