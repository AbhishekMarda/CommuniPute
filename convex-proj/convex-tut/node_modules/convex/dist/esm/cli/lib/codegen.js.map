{
  "version": 3,
  "sources": ["../../../../src/cli/lib/codegen.ts"],
  "sourcesContent": ["import esbuild from \"esbuild\";\nimport path from \"path\";\nimport prettier from \"prettier\";\nimport { mkdtemp, nodeFs, TempDir } from \"../../bundler/fs.js\";\nimport { actionsDir, allEntryPoints, walkDir } from \"../../bundler/index.js\";\nimport { actionsTsconfigCodegen } from \"../codegen_templates/actionsTsconfig.js\";\nimport { apiCodegen } from \"../codegen_templates/api.js\";\nimport { GeneratedJsWithTypes } from \"../codegen_templates/common.js\";\nimport {\n  dataModel,\n  dataModelWithoutSchema,\n} from \"../codegen_templates/dataModel.js\";\nimport { reactCodegen } from \"../codegen_templates/react.js\";\nimport { readmeCodegen } from \"../codegen_templates/readme.js\";\nimport { serverCodegen } from \"../codegen_templates/server.js\";\nimport { tsconfigCodegen } from \"../codegen_templates/tsconfig.js\";\nimport { ProjectConfig } from \"./config.js\";\nimport { Context } from \"./context.js\";\nimport {\n  processTypeCheckResult,\n  typeCheckFunctions,\n  TypeCheckMode,\n} from \"./typecheck.js\";\nimport { functionsDir } from \"./utils.js\";\n\n/**\n * Run prettier so we don't have to think about formatting!\n *\n * This is a little sketchy because we are using the default prettier config\n * (not our user's one) but it's better than nothing.\n */\nfunction format(source: string, filetype: string): string {\n  return prettier.format(source, { parser: filetype });\n}\n\n/**\n * Compile ESM-format (import/export) to CJS (require/exports).\n *\n * Codegen output is generally ESM format, but in some Node zero-bundle\n * setups it's useful to use CommonJS format for JavaScript output.\n */\nfunction compileToCommonJS(source: string): string {\n  const { code } = esbuild.transformSync(source, {\n    format: \"cjs\",\n    target: \"node14\",\n    minify: false,\n  });\n  return code;\n}\n\nfunction writeFile(\n  ctx: Context,\n  filename: string,\n  source: string,\n  dir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet: boolean,\n  filetype = \"typescript\"\n) {\n  const formattedSource = format(source, filetype);\n  const dest = path.join(dir.tmpPath, filename);\n  if (debug) {\n    console.log(`# ${filename}`);\n    console.log(formattedSource);\n    return;\n  }\n  if (dryRun) {\n    if (ctx.fs.exists(dest)) {\n      const fileText = ctx.fs.readUtf8File(dest);\n      if (fileText !== formattedSource) {\n        console.log(`Command would replace file: ${dest}`);\n      }\n    } else {\n      console.log(`Command would create file: ${dest}`);\n    }\n    return;\n  }\n\n  if (!quiet) {\n    console.log(`writing ${filename}`);\n  }\n\n  nodeFs.writeUtf8File(dest, formattedSource);\n}\n\nfunction writeJsWithTypes(\n  ctx: Context,\n  name: string,\n  content: GeneratedJsWithTypes,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet: boolean,\n  commonjs: boolean\n) {\n  writeFile(ctx, `${name}.d.ts`, content.DTS, codegenDir, dryRun, debug, quiet);\n  if (content.JS) {\n    const js = commonjs ? compileToCommonJS(content.JS) : content.JS;\n    writeFile(ctx, `${name}.js`, js, codegenDir, dryRun, debug, quiet);\n  }\n}\n\nfunction doServerCodegen(\n  ctx: Context,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  hasSchemaFile: boolean,\n  debug: boolean,\n  quiet = false,\n  commonjs = false\n) {\n  if (hasSchemaFile) {\n    writeJsWithTypes(\n      ctx,\n      \"dataModel\",\n      dataModel,\n      codegenDir,\n      dryRun,\n      debug,\n      quiet,\n      commonjs\n    );\n  } else {\n    writeJsWithTypes(\n      ctx,\n      \"dataModel\",\n      dataModelWithoutSchema,\n      codegenDir,\n      dryRun,\n      debug,\n      quiet,\n      commonjs\n    );\n  }\n  writeJsWithTypes(\n    ctx,\n    \"server\",\n    serverCodegen(),\n    codegenDir,\n    dryRun,\n    debug,\n    quiet,\n    commonjs\n  );\n}\n\nasync function doApiCodegen(\n  ctx: Context,\n  functionsDir: string,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet = false,\n  commonjs = false\n) {\n  const modulePaths = (await allEntryPoints(ctx.fs, functionsDir, false)).map(\n    entryPoint => path.relative(functionsDir, entryPoint)\n  );\n  writeJsWithTypes(\n    ctx,\n    \"api\",\n    apiCodegen(modulePaths),\n    codegenDir,\n    dryRun,\n    debug,\n    quiet,\n    commonjs\n  );\n}\n\nasync function doReactCodegen(\n  ctx: Context,\n  codegenDir: TempDir,\n  dryRun: boolean,\n  debug: boolean,\n  quiet = false,\n  commonjs = false\n) {\n  writeJsWithTypes(\n    ctx,\n    \"react\",\n    reactCodegen(),\n    codegenDir,\n    dryRun,\n    debug,\n    quiet,\n    commonjs\n  );\n}\n\nexport async function doCodegen({\n  ctx,\n  projectConfig,\n  configPath,\n  typeCheckMode,\n  dryRun = false,\n  debug = false,\n  quiet = false,\n  commonjs = false,\n}: {\n  ctx: Context;\n  projectConfig: ProjectConfig;\n  configPath: string;\n  typeCheckMode: TypeCheckMode;\n  dryRun?: boolean;\n  debug?: boolean;\n  quiet?: boolean;\n  commonjs?: boolean;\n}): Promise<void> {\n  const funcDir = functionsDir(configPath, projectConfig);\n\n  // Delete the old _generated.ts because v0.1.2 used to put the react generated\n  // code there\n  const legacyCodegenPath = path.join(funcDir, \"_generated.ts\");\n  if (ctx.fs.exists(legacyCodegenPath)) {\n    if (!dryRun) {\n      console.log(`Deleting legacy codegen file: ${legacyCodegenPath}}`);\n      ctx.fs.unlink(legacyCodegenPath);\n    } else {\n      console.log(\n        `Command would delete legacy codegen file: ${legacyCodegenPath}}`\n      );\n    }\n  }\n\n  // Create the function dir if it doesn't already exist.\n  ctx.fs.mkdir(funcDir, { allowExisting: true });\n\n  const schemaPath = path.join(funcDir, \"schema.ts\");\n  const hasSchemaFile = ctx.fs.exists(schemaPath);\n\n  // Recreate the codegen directory in a temp location\n  await mkdtemp(\"_generated\", async tempCodegenDir => {\n    // Do things in a careful order so that we always generate code in\n    // dependency order.\n    //\n    // Ideally we would also typecheck sources before we use them. However,\n    // we can't typecheck a single file while respecting the tsconfig, which can\n    // produce misleading errors. Instead, we'll typecheck the generated code at\n    // the end.\n    // -\n    //\n    // The dependency chain is:\n    // _generated/react.js\n    // -> query and mutation functions\n    // -> _generated/server.js\n    // -> schema.ts\n    // (where -> means \"depends on\")\n\n    // 1. Use the schema.ts file to create the server codegen\n    doServerCodegen(\n      ctx,\n      tempCodegenDir,\n      dryRun,\n      hasSchemaFile,\n      debug,\n      quiet,\n      commonjs\n    );\n\n    // 2. Generate API\n    await doApiCodegen(ctx, funcDir, tempCodegenDir, dryRun, debug, quiet);\n\n    // 3. Generate the React code\n    await doReactCodegen(ctx, tempCodegenDir, dryRun, debug, quiet, commonjs);\n\n    // Replace the codegen directory with its new contents\n    if (!debug && !dryRun) {\n      const codegenDir = path.join(funcDir, \"_generated\");\n      syncFromTemp(ctx, tempCodegenDir, codegenDir, true);\n    }\n\n    // Generated code is updated, Typecheck the query and mutation functions.\n    // TODO Only server codegen is necessary for this, we could bail out sooner\n    // by typechecking as soon as that code exists. CX-2577\n    await processTypeCheckResult(ctx, typeCheckMode, () =>\n      typeCheckFunctions(ctx, funcDir)\n    );\n  });\n}\n\n// TODO: this externalizes partial state to the app framework (eg vite)\n// Frameworks appear to be resilient to this - but if we find issues, we\n// could tighten this up per exchangedata(2) and renameat(2) - working\n// under the assumption that the temp dir is on the same filesystem\n// as the watched directory.\nfunction syncFromTemp(\n  ctx: Context,\n  tempDir: TempDir,\n  destDir: string,\n  eliminateExtras: boolean // Eliminate extra files in destDir\n) {\n  ctx.fs.mkdir(destDir, { allowExisting: true });\n  const added = new Set();\n  // Copy in the newly codegen'd files\n  // Use Array.from to prevent mutation-while-iterating\n  for (const { isDir, path: fpath } of Array.from(\n    walkDir(ctx.fs, tempDir.tmpPath)\n  )) {\n    const relPath = path.relative(tempDir.tmpPath, fpath);\n    const destPath = path.join(destDir, relPath);\n\n    // Remove anything existing at the dest path.\n    if (ctx.fs.exists(destPath)) {\n      if (ctx.fs.stat(destPath).isDirectory()) {\n        if (!isDir) {\n          // converting dir -> file. Blow away old dir.\n          ctx.fs.rm(destPath, { recursive: true });\n        }\n        // Keep directory around in this case.\n      } else {\n        // Blow away files\n        ctx.fs.unlink(destPath);\n      }\n    }\n\n    // Move in the new file\n    if (isDir) {\n      ctx.fs.mkdir(destPath, { allowExisting: true });\n    } else {\n      ctx.fs.renameFile(fpath, destPath);\n    }\n    added.add(destPath);\n  }\n  // Eliminate any extra files/dirs in the destDir. Iterate in reverse topological\n  // because we're removing files.\n  // Use Array.from to prevent mutation-while-iterating\n  if (eliminateExtras) {\n    const destEntries = Array.from(walkDir(ctx.fs, destDir)).reverse();\n    for (const { isDir, path: fpath } of destEntries) {\n      if (!added.has(fpath)) {\n        if (isDir) {\n          ctx.fs.rmdir(fpath);\n        } else {\n          ctx.fs.unlink(fpath);\n        }\n      }\n    }\n  }\n}\n\n// Code generated on new project init, after which these files are not\n// automatically written again in case developers have modified them.\nexport async function doInitCodegen(\n  ctx: Context,\n  functionsDir: string,\n  quiet = false,\n  dryRun = false,\n  debug = false\n) {\n  const actionsPath = path.join(functionsDir, actionsDir);\n  const hasActionsDir = ctx.fs.exists(actionsPath);\n\n  await mkdtemp(\"convex\", async tempFunctionsDir => {\n    doReadmeCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);\n    doTsconfigCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);\n    if (hasActionsDir) {\n      ctx.fs.mkdir(path.join(tempFunctionsDir.tmpPath, actionsDir), {\n        allowExisting: true,\n      });\n      doActionsTsconfigCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);\n    }\n    syncFromTemp(ctx, tempFunctionsDir, functionsDir, false);\n  });\n}\nfunction doReadmeCodegen(\n  ctx: Context,\n  tempFunctionsDir: TempDir,\n  dryRun = false,\n  debug = false,\n  quiet = false\n) {\n  writeFile(\n    ctx,\n    \"README.md\",\n    readmeCodegen(),\n    tempFunctionsDir,\n    dryRun,\n    debug,\n    quiet,\n    \"markdown\"\n  );\n}\nfunction doTsconfigCodegen(\n  ctx: Context,\n  tempFunctionsDir: TempDir,\n  dryRun = false,\n  debug = false,\n  quiet = false\n) {\n  writeFile(\n    ctx,\n    \"tsconfig.json\",\n    tsconfigCodegen(),\n    tempFunctionsDir,\n    dryRun,\n    debug,\n    quiet,\n    \"json\"\n  );\n}\nfunction doActionsTsconfigCodegen(\n  ctx: Context,\n  tempFunctionsDir: TempDir,\n  dryRun = false,\n  debug = false,\n  quiet = false\n) {\n  writeFile(\n    ctx,\n    path.join(actionsDir, \"tsconfig.json\"),\n    actionsTsconfigCodegen(),\n    tempFunctionsDir,\n    dryRun,\n    debug,\n    quiet,\n    \"json\"\n  );\n}\n"],
  "mappings": "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",
  "names": ["functionsDir"]
}
