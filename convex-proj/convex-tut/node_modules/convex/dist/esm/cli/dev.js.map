{
  "version": 3,
  "sources": ["../../../src/cli/dev.ts"],
  "sourcesContent": ["import boxen from \"boxen\";\nimport chalk from \"chalk\";\nimport { Command, Option } from \"commander\";\nimport path from \"path\";\nimport { performance } from \"perf_hooks\";\nimport { getDevDeployment, getUrlAndAdminKey } from \"./lib/api\";\nimport { readProjectConfig } from \"./lib/config\";\nimport { oneoffContext } from \"./lib/context\";\nimport { offerToWriteToEnv } from \"./lib/envvars\";\nimport { checkAuthorization, performLogin } from \"./lib/login\";\nimport { PushOptions, runPush } from \"./lib/push\";\nimport { ensureProjectDirectory, formatDuration } from \"./lib/utils\";\nimport { FatalError, WatchContext, Watcher } from \"./lib/watch\";\n\nexport const dev = new Command(\"dev\")\n  .description(\n    \"Watch the local filesystem. When your Convex functions change, push them to your dev deployment and update generated code.\"\n  )\n  .option(\"-v, --verbose\", \"Show full listing of changes\")\n  .addOption(\n    new Option(\n      \"--typecheck <mode>\",\n      `Check TypeScript files with \\`tsc --noEmit\\`.`\n    )\n      .choices([\"enable\", \"try\", \"disable\"])\n      .default(\"try\")\n  )\n  .option(\"--save-url\", \"Save the dev deployment URL to .env.local\")\n  .option(\"--no-save-url\", \"Do not save dev deployment URL to .env.local\")\n  .addOption(\n    new Option(\n      \"--prod\",\n      \"Develop live against this project's production deployment.\"\n    ).hideHelp()\n  )\n  .addOption(new Option(\"--trace-events\").hideHelp())\n  .addOption(new Option(\"--once\").hideHelp())\n  .addOption(new Option(\"--admin-key <adminKey>\").hideHelp())\n  .addOption(new Option(\"--url <url>\").hideHelp())\n  .addOption(\n    new Option(\"--codegen <mode>\", \"Regenerate code in `convex/_generated/`\")\n      .choices([\"enable\", \"disable\"])\n      .default(\"enable\")\n  )\n  .action(async cmdOptions => {\n    const ctx = oneoffContext;\n\n    const saveUrl =\n      cmdOptions.saveUrl === true\n        ? \"yes\"\n        : cmdOptions.saveUrl === false\n        ? \"no\"\n        : \"ask\";\n\n    if (!cmdOptions.url || !cmdOptions.adminKey) {\n      if (!(await checkAuthorization(ctx))) {\n        await performLogin(ctx);\n      }\n    }\n\n    await ensureProjectDirectory(ctx, true);\n\n    const config = await readProjectConfig(oneoffContext);\n\n    const projectSlug = config.projectConfig.project;\n    const teamSlug = config.projectConfig.team;\n\n    let deployment;\n    if (!cmdOptions.url || !cmdOptions.adminKey) {\n      if (cmdOptions.prod) {\n        deployment = await getUrlAndAdminKey(\n          ctx,\n          config.projectConfig.project,\n          config.projectConfig.team,\n          \"prod\"\n        );\n        console.error(\"Found  deployment ready\");\n      } else {\n        deployment = await getDevDeployment(oneoffContext, {\n          projectSlug,\n          teamSlug,\n        });\n      }\n    }\n    const adminKey = cmdOptions.adminKey ?? deployment?.adminKey;\n    const url = cmdOptions.url ?? deployment?.url;\n    const options: PushOptions = {\n      adminKey,\n      verbose: !!cmdOptions.verbose,\n      dryRun: false,\n      typecheck: cmdOptions.typecheck,\n      debug: false,\n      codegen: cmdOptions.codegen === \"enable\",\n      url,\n    };\n    let watcher: Watcher | undefined;\n    let numFailures = 0;\n\n    await offerToWriteToEnv(ctx, \"dev\", url, saveUrl);\n\n    const boxedText =\n      chalk.whiteBright.bold(\n        `${\n          cmdOptions.prod ? \"Production\" : \"Development\"\n        } deployment at ${url} ready!`\n      ) +\n      chalk.white(\n        \"\\n\\nKeep this command running to sync Convex functions when they change.\"\n      );\n    const boxenOptions = {\n      align: \"center\",\n      padding: 1,\n      margin: 1,\n      borderColor: \"green\",\n      backgroundColor: \"#555555\",\n    } as const;\n    if (!cmdOptions.once) {\n      console.log(boxen(boxedText, boxenOptions));\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      console.log(\"Preparing Convex functions...\");\n      const start = performance.now();\n      const ctx = new WatchContext(cmdOptions.traceEvents);\n\n      // If the project or team slugs change, exit because that's the\n      // simplest thing to do.\n      const config = await readProjectConfig(ctx);\n      if (\n        projectSlug !== config.projectConfig.project ||\n        teamSlug !== config.projectConfig.team\n      ) {\n        console.log(\"Detected a change in your `convex.json`. Exiting...\");\n        return await ctx.fatalError(1, \"fs\");\n      }\n\n      try {\n        await runPush(ctx, options);\n        const end = performance.now();\n        numFailures = 0;\n        console.log(\n          chalk.green(\n            `Convex functions ready! (${formatDuration(end - start)})`\n          )\n        );\n      } catch (e: any) {\n        // Crash the app on unexpected errors.\n        if (!(e instanceof FatalError) || !e.reason) {\n          throw e;\n        }\n        // Retry after an exponential backoff if we hit a network error.\n        if (e.reason === \"network\") {\n          const delay = nextBackoff(numFailures);\n          numFailures += 1;\n          console.log(\n            chalk.yellow(\n              `Failed due to network error, retrying in ${formatDuration(\n                delay\n              )}...`\n            )\n          );\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        // Fall through if we had a filesystem-based error.\n        console.assert(e.reason === \"fs\");\n        if (cmdOptions.once) {\n          await ctx.fatalError(1, \"fs\");\n        }\n      }\n      if (cmdOptions.once) {\n        return;\n      }\n      const observations = ctx.fs.finalize();\n      if (observations === \"invalidated\") {\n        console.log(\"Filesystem changed during push, retrying...\");\n        continue;\n      }\n      // Initialize the watcher if we haven't done it already. Chokidar expects to have a\n      // nonempty watch set at initialization, so we can't do it before running our first\n      // push.\n      if (!watcher) {\n        watcher = new Watcher(observations);\n        await watcher.ready();\n      }\n      // Watch new directories if needed.\n      watcher.update(observations);\n\n      // Process events until we find one that overlaps with our previous observations.\n      let anyChanges = false;\n      do {\n        await watcher.waitForEvent();\n        for (const event of watcher.drainEvents()) {\n          if (cmdOptions.traceEvents) {\n            console.log(\n              \"Processing\",\n              event.name,\n              path.relative(\"\", event.absPath)\n            );\n          }\n          const result = observations.overlaps(event);\n          if (result.overlaps) {\n            const relPath = path.relative(\"\", event.absPath);\n            if (cmdOptions.traceEvents) {\n              console.log(`${relPath} ${result.reason}, rebuilding...`);\n            }\n            anyChanges = true;\n            break;\n          }\n        }\n      } while (!anyChanges);\n\n      // Wait for the filesystem to quiesce before starting a new push. It's okay to\n      // drop filesystem events at this stage since we're already committed to doing\n      // a push and resubscribing based on that push's observations.\n      let deadline = performance.now() + quiescenceDelay;\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const now = performance.now();\n        if (now >= deadline) {\n          break;\n        }\n        const remaining = deadline - now;\n        if (cmdOptions.traceEvents) {\n          console.log(`Waiting for ${formatDuration(remaining)} to quiesce...`);\n        }\n        const remainingWait = new Promise<\"timeout\">(resolve =>\n          setTimeout(() => resolve(\"timeout\"), deadline - now)\n        );\n        const result = await Promise.race([\n          remainingWait,\n          watcher.waitForEvent().then<\"newEvents\">(() => \"newEvents\"),\n        ]);\n        if (result === \"newEvents\") {\n          for (const event of watcher.drainEvents()) {\n            const result = observations.overlaps(event);\n            // Delay another `quiescenceDelay` since we had an overlapping event.\n            if (result.overlaps) {\n              if (cmdOptions.traceEvents) {\n                console.log(\n                  `Received an overlapping event at ${event.absPath}, delaying push.`\n                );\n              }\n              deadline = performance.now() + quiescenceDelay;\n            }\n          }\n        } else {\n          console.assert(result === \"timeout\");\n          // Let the check above `break` from the loop if we're past our deadlne.\n        }\n      }\n    }\n  });\n\nconst initialBackoff = 500;\nconst maxBackoff = 16000;\nconst quiescenceDelay = 500;\n\nfunction nextBackoff(prevFailures: number): number {\n  const baseBackoff = initialBackoff * Math.pow(2, prevFailures);\n  const actualBackoff = Math.min(baseBackoff, maxBackoff);\n  const jitter = actualBackoff * (Math.random() - 0.5);\n  return actualBackoff + jitter;\n}\n"],
  "mappings": "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",
  "names": ["ctx", "config", "result"]
}
