"use strict";
import path from "path";
import chalk from "chalk";
import esbuild from "esbuild";
export { nodeFs, RecordingFs } from "./fs.js";
export const actionsDir = "actions";
export function* walkDir(fs, dirPath) {
  for (const dirEntry of fs.listDir(dirPath)) {
    const childPath = path.join(dirPath, dirEntry.name);
    if (dirEntry.isDirectory()) {
      yield { isDir: true, path: childPath };
      yield* walkDir(fs, childPath);
    } else if (dirEntry.isFile()) {
      yield { isDir: false, path: childPath };
    }
  }
}
export class BundleError extends Error {
}
async function doEsbuild(fs, dir, entryPoints2, generateSourceMaps, platform, chunksFolder) {
  try {
    const result = await esbuild.build({
      entryPoints: entryPoints2,
      bundle: true,
      platform,
      format: "esm",
      target: "esnext",
      outdir: "out",
      outbase: dir,
      write: false,
      sourcemap: generateSourceMaps,
      splitting: true,
      chunkNames: path.join(chunksFolder, "[hash]"),
      treeShaking: true,
      minify: false,
      metafile: true
    });
    for (const [relPath, input] of Object.entries(result.metafile.inputs)) {
      if (relPath.indexOf("(disabled):") !== -1) {
        continue;
      }
      const absPath = path.resolve(relPath);
      const st = fs.stat(absPath);
      if (st.size !== input.bytes) {
        throw new Error(
          `Bundled file ${absPath} changed right after esbuild invocation`
        );
      }
      fs.registerPath(absPath, st);
    }
    return result;
  } catch (err) {
    throw new BundleError(`esbuild failed: ${err.toString()}`);
  }
}
export async function bundle(fs, dir, entryPoints2, generateSourceMaps, platform, chunksFolder = "_deps") {
  const result = await doEsbuild(
    fs,
    dir,
    entryPoints2,
    generateSourceMaps,
    platform,
    chunksFolder
  );
  if (result.errors.length) {
    for (const error of result.errors) {
      console.log(chalk.red(`esbuild error: ${error.text}`));
    }
    throw new BundleError("esbuild failed");
  }
  for (const warning of result.warnings) {
    console.log(chalk.yellow(`esbuild warning: ${warning.text}`));
  }
  const sourceMaps = /* @__PURE__ */ new Map();
  const modules = [];
  for (const outputFile of result.outputFiles) {
    const relPath = path.relative(path.normalize("out"), outputFile.path);
    if (path.extname(relPath) === ".map") {
      sourceMaps.set(relPath, outputFile.text);
      continue;
    }
    const posixRelPath = relPath.split(path.sep).join(path.posix.sep);
    modules.push({ path: posixRelPath, source: outputFile.text });
  }
  for (const module of modules) {
    const sourceMapPath = module.path + ".map";
    const sourceMap = sourceMaps.get(sourceMapPath);
    if (sourceMap) {
      module.sourceMap = sourceMap;
    }
  }
  return modules;
}
export async function bundleSchema(fs, dir) {
  return bundle(fs, dir, [path.resolve(dir, "schema.ts")], true, "neutral");
}
function escapeRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
async function entryPoints(fs, dir, includePattern, verbose) {
  const entryPoints2 = [];
  for (const { isDir, path: fpath } of walkDir(fs, dir)) {
    if (isDir) {
      continue;
    }
    const relPath = path.relative(dir, fpath);
    const base = path.parse(fpath).base;
    const log = (line) => {
      if (verbose) {
        console.log(line);
      }
    };
    if (!relPath.match(includePattern)) {
      continue;
    } else if (relPath.startsWith("_deps" + path.sep)) {
      throw new Error(
        `The path "${fpath}" is within the "_deps" directory, which is reserved for dependencies. Please move your code to another directory.`
      );
    } else if (relPath.startsWith("_generated" + path.sep)) {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base.startsWith(".")) {
      log(chalk.yellow(`Skipping dotfile ${fpath}`));
    } else if (base === "README.md") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base === "_generated.ts") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base === "schema.ts") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base.includes(".test.")) {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (base === "tsconfig.json") {
      log(chalk.yellow(`Skipping ${fpath}`));
    } else if (relPath.includes(" ")) {
      log(chalk.yellow(`Skipping ${relPath} because it contains a space`));
    } else {
      log(chalk.green(`Preparing ${fpath}`));
      entryPoints2.push(fpath);
    }
  }
  return entryPoints2;
}
export async function allEntryPoints(fs, dir, verbose) {
  return entryPoints(fs, dir, new RegExp(".*"), verbose);
}
export async function databaseEntryPoints(fs, dir, verbose) {
  const excludePrefix = actionsDir + path.sep;
  return entryPoints(
    fs,
    dir,
    RegExp(`^(?!${escapeRegex(excludePrefix)})`),
    verbose
  );
}
export async function actionsEntryPoints(fs, dir, verbose) {
  const prefix = actionsDir + path.sep;
  return entryPoints(fs, dir, RegExp(`^${escapeRegex(prefix)}`), verbose);
}
//# sourceMappingURL=index.js.map
