{
  "version": 3,
  "sources": ["../../../src/schema/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n/**\n * Utilities for defining the schema of your Convex project.\n *\n * ## Usage\n *\n * Schemas should be placed in a `schema.ts` file in your `convex/` directory.\n *\n * Schema definitions should be built using {@link defineSchema},\n * {@link defineTable}, and {@link s}. Make sure to export the schema as the\n * default export.\n *\n * ```ts\n * import { defineSchema, defineTable, s } from \"convex/schema\";\n *\n *  export default defineSchema({\n *    messages: defineTable({\n *      body: s.string(),\n *      user: s.id(\"users\"),\n *    }),\n *    users: defineTable({\n *      name: s.string(),\n *    }),\n *  });\n * ```\n *\n * To learn more about schemas, see [Defining a Schema](https://docs.convex.dev/using/schemas).\n * @module\n */\nimport { GenericId } from \"../values/index.js\";\nimport {\n  AnyDataModel,\n  DocumentByInfo,\n  GenericDataModel,\n  GenericDocument,\n  GenericTableIndexes,\n  GenericTableInfo,\n  GenericTableSearchIndexes,\n  Indexes,\n  SearchIndexes,\n} from \"../server/data_model.js\";\nimport {\n  IdField,\n  IndexTiebreakerField,\n  SystemFields,\n  SystemIndexes,\n} from \"../server/system_fields.js\";\nimport { Expand } from \"../type_utils.js\";\n\n/**\n * A Convex type defined in a schema.\n *\n * These should be constructed using {@link s}.\n *\n * This class encapsulates:\n * - The TypeScript type of this Convex type.\n * - Whether this field should be optional if it's included in an object.\n * - The TypeScript type for the set of index field paths that can be used to\n * build indexes on this type.\n * - The table names referenced in `s.id` usages in this type.\n * @public\n */\nexport class SchemaType<\n  TypeScriptType,\n  IsOptional extends boolean = false,\n  FieldPaths extends string = never\n> {\n  readonly type!: TypeScriptType;\n  readonly isOptional!: IsOptional;\n  readonly fieldPaths!: FieldPaths;\n\n  // Property for a bit of nominal type safety.\n  private _isSchemaType: undefined;\n\n  readonly referencedTableNames: Set<string>;\n  constructor(referencedTableNames: Set<string> = new Set()) {\n    this.referencedTableNames = referencedTableNames;\n  }\n}\n\n/**\n * The schema builder.\n *\n * This builder allows you to define the types of documents stored in Convex.\n * @public\n */\nexport const s = {\n  id<TableName extends string>(\n    tableName: TableName\n  ): SchemaType<GenericId<TableName>> {\n    return new SchemaType(new Set([tableName]));\n  },\n  null(): SchemaType<null> {\n    return new SchemaType();\n  },\n  number(): SchemaType<number> {\n    return new SchemaType();\n  },\n  bigint(): SchemaType<bigint> {\n    return new SchemaType();\n  },\n  boolean(): SchemaType<boolean> {\n    return new SchemaType();\n  },\n  string(): SchemaType<string> {\n    return new SchemaType();\n  },\n  bytes(): SchemaType<ArrayBuffer> {\n    return new SchemaType();\n  },\n  literal<T extends string | number | bigint | boolean>(\n    literal: T\n  ): SchemaType<T> {\n    return new SchemaType();\n  },\n  array<T>(values: SchemaType<T, false, any>): SchemaType<T[]> {\n    return new SchemaType(values.referencedTableNames);\n  },\n  set<T>(values: SchemaType<T, false, any>): SchemaType<Set<T>> {\n    return new SchemaType(values.referencedTableNames);\n  },\n  map<K, V>(\n    keys: SchemaType<K, false, any>,\n    values: SchemaType<V, false, any>\n  ): SchemaType<Map<K, V>> {\n    return new SchemaType(\n      new Set([...keys.referencedTableNames, ...values.referencedTableNames])\n    );\n  },\n  object<T extends Record<string, SchemaType<any, any, any>>>(\n    schema: T\n  ): ObjectSchemaType<T> {\n    const referencedTableNames = new Set<string>();\n    for (const schemaType of Object.values(schema)) {\n      for (const tableName of schemaType.referencedTableNames) {\n        referencedTableNames.add(tableName);\n      }\n    }\n    return new SchemaType(referencedTableNames);\n  },\n  union<\n    T extends [\n      SchemaType<any, false, any>,\n      SchemaType<any, false, any>,\n      ...SchemaType<any, false, any>[]\n    ]\n  >(\n    ...schemaTypes: T\n  ): SchemaType<T[number][\"type\"], false, T[number][\"fieldPaths\"]> {\n    const referencedTableNames = new Set<string>();\n    for (const schemaType of schemaTypes) {\n      for (const tableName of schemaType.referencedTableNames) {\n        referencedTableNames.add(tableName);\n      }\n    }\n    return new SchemaType(referencedTableNames);\n  },\n  any(): SchemaType<any, false, string> {\n    return new SchemaType();\n  },\n  optional<T extends SchemaType<any, false, any>>(\n    inner: T\n  ): SchemaType<T[\"type\"], true, T[\"fieldPaths\"]> {\n    return new SchemaType(inner.referencedTableNames) as SchemaType<\n      T[\"type\"],\n      true,\n      T[\"fieldPaths\"]\n    >;\n  },\n};\n/**\n * Calculate the {@link SchemaType} for an object.\n *\n * This is used within the SchemaBuilder {@link s}.\n * @public\n */\ntype ObjectSchemaType<\n  SchemaValueType extends Record<string, SchemaType<any, any, any>>\n> = SchemaType<\n  // Compute the TypeScript type for this object.\n  // Map each key to the corresponding type making the optional ones optional.\n  Expand<\n    {\n      [Property in OptionalKeys<SchemaValueType>]?: SchemaValueType[Property][\"type\"];\n    } & {\n      [Property in RequiredKeys<SchemaValueType>]: SchemaValueType[Property][\"type\"];\n    }\n  >,\n  false,\n  // Compute the field paths for this object. For every property in the object\n  // Add on a field path for that property and extend all the field paths in the\n  // value.\n  {\n    [Property in keyof SchemaValueType]:\n      | JoinFieldPaths<\n          Property & string,\n          SchemaValueType[Property][\"fieldPaths\"]\n        >\n      | Property;\n  }[keyof SchemaValueType] &\n    string\n>;\n\ntype OptionalKeys<\n  SchemaValueType extends Record<string, SchemaType<any, any, any>>\n> = {\n  [Property in keyof SchemaValueType]: SchemaValueType[Property][\"isOptional\"] extends true\n    ? Property\n    : never;\n}[keyof SchemaValueType];\n\ntype RequiredKeys<\n  SchemaValueType extends Record<string, SchemaType<any, any, any>>\n> = Exclude<keyof SchemaValueType, OptionalKeys<SchemaValueType>>;\n/**\n * Join together two index field paths.\n *\n * This is used within the SchemaBuilder {@link s}.\n * @public\n */\ntype JoinFieldPaths<\n  Start extends string,\n  End extends string\n> = `${Start}.${End}`;\n\n/**\n * Extract all of the index field paths within a {@link SchemaType}.\n *\n * This is used within {@link defineTable}.\n * @public\n */\ntype ExtractFieldPaths<T extends SchemaType<any, any, any>> =\n  // Add in the system fields available in index definitions.\n  // This should be everything except for `_id` because thats added to indexes\n  // automatically.\n  T[\"fieldPaths\"] | keyof SystemFields;\n\n/**\n * Extract the {@link GenericDocument} within a {@link SchemaType} and\n * add on the system fields.\n *\n * This is used within {@link defineTable}.\n * @public\n */\ntype ExtractDocument<T extends SchemaType<any, any, any>> =\n  // Add the system fields to `Value` (except `_id` because it depends on\n  //the table name) and trick TypeScript into expanding them.\n  Expand<SystemFields & T[\"type\"]>;\n\n/**\n * The configuration for a search index.\n *\n * @internal\n */\nexport interface SearchIndexConfig<\n  SearchField extends string,\n  FilterFields extends string\n> {\n  /**\n   * The field to index for full text search.\n   *\n   * This must be a field of type `string`.\n   */\n  searchField: SearchField;\n\n  /**\n   * Additional fields to index for fast filtering when running search queries.\n   */\n  filterFields?: FilterFields[];\n}\n\n/**\n * The definition of a table within a schema.\n *\n * This should be produced by using {@link defineTable}.\n * @public\n */\nexport class TableDefinition<\n  Document extends GenericDocument = GenericDocument,\n  FieldPaths extends string = string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Indexes extends GenericTableIndexes = {},\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  SearchIndexes extends GenericTableSearchIndexes = {}\n> {\n  private indexes: { indexDescriptor: string; fields: string[] }[];\n  private searchIndexes: {\n    indexDescriptor: string;\n    searchField: string;\n    filterFields: string[];\n  }[];\n  // The type of documents stored in this table.\n  private documentType: SchemaType<any, any, any>;\n\n  /**\n   * @internal\n   */\n  constructor(documentType: SchemaType<any, any, any>) {\n    this.indexes = [];\n    this.searchIndexes = [];\n    this.documentType = documentType;\n  }\n\n  /**\n   * Define an index on this table.\n   *\n   * To learn about indexes, see [Defining Indexes](https://docs.convex.dev/using/indexes).\n   *\n   * @param name - The name of the index.\n   * @param fields - The fields to index, in order. Must specify at least one\n   * field.\n   * @returns A {@link TableDefinition} with this index included.\n   */\n  index<\n    IndexName extends string,\n    FirstFieldPath extends FieldPaths,\n    RestFieldPaths extends FieldPaths[]\n  >(\n    name: IndexName,\n    fields: [FirstFieldPath, ...RestFieldPaths]\n  ): TableDefinition<\n    Document,\n    FieldPaths,\n    // Update `Indexes` to include the new index and use `Expand` to make the\n    // types look pretty in editors.\n    Expand<\n      Indexes &\n        Record<\n          IndexName,\n          [FirstFieldPath, ...RestFieldPaths, IndexTiebreakerField]\n        >\n    >,\n    SearchIndexes\n  > {\n    this.indexes.push({ indexDescriptor: name, fields });\n    return this;\n  }\n\n  /**\n   * Define a search index on this table.\n   *\n   * @param name - The name of the index.\n   * @param indexConfig - The search index configuration object.\n   * @returns A {@link TableDefinition} with this search index included.\n   * @internal\n   */\n  searchIndex<\n    IndexName extends string,\n    SearchField extends FieldPaths,\n    FilterFields extends FieldPaths = never\n  >(\n    name: IndexName,\n    indexConfig: Expand<SearchIndexConfig<SearchField, FilterFields>>\n  ): TableDefinition<\n    Document,\n    FieldPaths,\n    Indexes,\n    // Update `SearchIndexes` to include the new index and use `Expand` to make\n    // the types look pretty in editors.\n    Expand<\n      SearchIndexes &\n        Record<\n          IndexName,\n          {\n            searchField: SearchField;\n            filterFields: FilterFields;\n          }\n        >\n    >\n  > {\n    this.searchIndexes.push({\n      indexDescriptor: name,\n      searchField: indexConfig.searchField,\n      filterFields: indexConfig.filterFields || [],\n    });\n    return this;\n  }\n\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    return {\n      indexes: this.indexes,\n      searchIndexes: this.searchIndexes,\n      referencedTableNames: this.documentType.referencedTableNames,\n    };\n  }\n}\n\n/**\n * Define a table in a schema.\n *\n * You can either specify the schema of your documents as an object like\n * ```ts\n * defineTable({\n *   field: s.string()\n * });\n * ```\n *\n * or as a schema type like\n * ```ts\n * defineTable(\n *  s.union(\n *    s.object({...}),\n *    s.object({...})\n *  )\n * );\n * ```\n *\n * @param documentSchema - The type of documents stored in this table.\n * @returns A {@link TableDefinition} for the table.\n *\n * @public\n */\nexport function defineTable<\n  DocumentSchema extends SchemaType<Record<string, any>, false, any>\n>(\n  documentSchema: DocumentSchema\n): TableDefinition<\n  ExtractDocument<DocumentSchema>,\n  ExtractFieldPaths<DocumentSchema>\n>;\n/**\n * Define a table in a schema.\n *\n * You can either specify the schema of your documents as an object like\n * ```ts\n * defineTable({\n *   field: s.string()\n * });\n * ```\n *\n * or as a schema type like\n * ```ts\n * defineTable(\n *  s.union(\n *    s.object({...}),\n *    s.object({...})\n *  )\n * );\n * ```\n *\n * @param documentSchema - The type of documents stored in this table.\n * @returns A {@link TableDefinition} for the table.\n *\n * @public\n */\nexport function defineTable<\n  DocumentSchema extends Record<string, SchemaType<any, any, any>>\n>(\n  documentSchema: DocumentSchema\n): TableDefinition<\n  ExtractDocument<ObjectSchemaType<DocumentSchema>>,\n  ExtractFieldPaths<ObjectSchemaType<DocumentSchema>>\n>;\nexport function defineTable<\n  DocumentSchema extends\n    | SchemaType<Record<string, any>, false, any>\n    | Record<string, SchemaType<any, any, any>>\n>(documentSchema: DocumentSchema): TableDefinition<any, any> {\n  if (documentSchema instanceof SchemaType) {\n    return new TableDefinition(documentSchema);\n  } else {\n    return new TableDefinition(s.object(documentSchema));\n  }\n}\n\n/**\n * A type describing the schema of a Convex project.\n *\n * This should be constructed using {@link defineSchema}, {@link defineTable},\n * and {@link s}.\n * @public\n */\nexport type GenericSchema = Record<string, TableDefinition>;\n\n/**\n *\n * The definition of a Convex project schema.\n *\n * This should be produced by using {@link defineSchema}.\n * @public\n */\nexport class SchemaDefinition<\n  Schema extends GenericSchema,\n  IsStrict extends boolean\n> {\n  public tables: Schema;\n  public isStrict: IsStrict;\n\n  /**\n   * @internal\n   */\n  constructor(tables: Schema, options?: DefineSchemaOptions<IsStrict>) {\n    this.tables = tables;\n    this.isStrict = !!options?.strict as IsStrict;\n  }\n\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export(): string {\n    const tableNames = new Set(Object.keys(this.tables));\n\n    return JSON.stringify({\n      tables: Object.entries(this.tables).map(([tableName, definition]) => {\n        const { indexes, searchIndexes, referencedTableNames } =\n          definition.export();\n\n        // Make sure all the referenced table names are actually defined.\n        for (const referencedTableName of referencedTableNames) {\n          if (!tableNames.has(referencedTableName)) {\n            throw new Error(\n              `SchemaValidationError: Table ${tableName} has a \\`s.id\\` ` +\n                `expression that references table ${referencedTableName} which isn't defined in the schema.`\n            );\n          }\n        }\n\n        return {\n          tableName,\n          indexes,\n          searchIndexes,\n        };\n      }),\n    });\n  }\n}\n\n/**\n * Options for {@link defineSchema}.\n *\n * @public\n */\nexport interface DefineSchemaOptions<IsStrict extends boolean> {\n  /**\n   * Whether to strictly enforce this schema.\n   *\n   * If this schema is not strictly enforced, its type will permit:\n   * 1. Using additional tables not explicitly listed in the schema.\n   * 2. Using additional properties not explicitly listed in the tables.\n   *\n   * Loose schemas are useful for rapid prototyping.\n   *\n   * By default the schema is considered strict.\n   */\n  strict?: IsStrict;\n}\n\n/**\n * Define the schema of this Convex project.\n *\n * This should be exported from a `schema.ts` file in your `convex/` directory\n * like:\n *\n * ```ts\n * export default defineSchema({\n *   ...\n * });\n * ```\n *\n * @param schema - A map from table name to {@link TableDefinition} for all of\n * the tables in this project.\n * @param options - Optional configuration. See {@link DefineSchemaOptions} for\n * a full description.\n * @returns The schema.\n *\n * @public\n */\nexport function defineSchema<\n  Schema extends GenericSchema,\n  IsStrict extends boolean = true\n>(\n  schema: Schema,\n  options?: DefineSchemaOptions<IsStrict>\n): SchemaDefinition<Schema, IsStrict> {\n  return new SchemaDefinition(schema, options);\n}\n\n/**\n * Internal type used in Convex code generation!\n *\n * Convert a {@link SchemaDefinition} into a {@link server.GenericDataModel}.\n *\n * @public\n */\nexport type DataModelFromSchemaDefinition<\n  SchemaDef extends SchemaDefinition<any, boolean>\n> = MaybeMakeLooseDataModel<\n  {\n    [TableName in keyof SchemaDef[\"tables\"] &\n      string]: SchemaDef[\"tables\"][TableName] extends TableDefinition<\n      infer Document,\n      infer FieldPaths,\n      infer Indexes,\n      infer SearchIndexes\n    >\n      ? MaybeMakeLooseTableInfo<\n          {\n            // We've already added all of the system fields except for `_id`.\n            // Add that here.\n            document: Expand<IdField<TableName> & Document>;\n            fieldPaths: keyof IdField<TableName> | FieldPaths;\n            indexes: Expand<Indexes & SystemIndexes>;\n            searchIndexes: SearchIndexes;\n          },\n          SchemaDef[\"isStrict\"]\n        >\n      : never;\n  },\n  SchemaDef[\"isStrict\"]\n>;\n\ntype MaybeMakeLooseDataModel<\n  DataModel extends GenericDataModel,\n  IsStrict extends boolean\n> = IsStrict extends true ? DataModel : Expand<DataModel & AnyDataModel>;\n\ntype MaybeMakeLooseTableInfo<\n  TableInfo extends GenericTableInfo,\n  IsStrict extends boolean\n> = IsStrict extends true\n  ? TableInfo\n  : {\n      document: Expand<\n        DocumentByInfo<TableInfo> & { [propertyName: string]: any }\n      >;\n      fieldPaths: string;\n      indexes: Indexes<TableInfo>;\n      searchIndexes: SearchIndexes<TableInfo>;\n    };\n"],
  "mappings": "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",
  "names": []
}
