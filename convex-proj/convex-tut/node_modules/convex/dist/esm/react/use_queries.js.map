{
  "version": 3,
  "sources": ["../../../src/react/use_queries.ts"],
  "sourcesContent": ["import { Value } from \"../values/index.js\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useConvexGeneric } from \"./index.js\";\nimport { GenericAPI, NamedQuery, QueryNames } from \"../api/index.js\";\nimport { CreateWatch, QueriesObserver } from \"./queries_observer.js\";\nimport { useSubscription } from \"./use_subscription.js\";\nimport { QueryJournal } from \"../browser/index.js\";\n\n/**\n * Load a variable number of reactive Convex queries.\n *\n * `useQueriesGeneric` is similar to {@link useQueryGeneric} but it allows\n * loading multiple queries which can be useful for loading a dynamic number\n * of queries without violating the rules of React hooks.\n *\n * This hook accepts an object whose keys are identifiers for each query and the\n * values are objects of `{ name: string, args: Value[] }`. The `name` is the\n * name of the Convex query function to load, and the `args` are the arguments to\n * that function.\n *\n * The hook returns an object that maps each identifier to the result of the query,\n * `undefined` if the query is still loading, or an instance of `Error` if the query\n * threw an exception.\n *\n * For example if you loaded a query like:\n * ```typescript\n * const results = useQueriesGeneric({\n *   messagesInGeneral: {\n *     name: \"listMessages\",\n *     args: [\"#general\"]\n *   }\n * });\n * ```\n * then the result would look like:\n * ```typescript\n * {\n *   messagesInGeneral: [{\n *     channel: \"#general\",\n *     body: \"hello\"\n *     _id: ...,\n *     _creationTime: ...\n *   }]\n * }\n * ```\n *\n * This React hook contains internal state that will cause a rerender\n * whenever any of the query results change.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * If you're using code generation, use the `useQueries` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param queries - An object mapping identifiers to objects of\n * `{name: string, args: Value[] }` describing which query functions to fetch.\n * @returns An object with the same keys as the input. The values are the result\n * of the query function, `undefined` if it's still loading, or an `Error` if\n * it threw an exception.\n *\n * @public\n */\nexport function useQueriesGeneric(\n  queries: RequestForQueries\n): Record<string, any | undefined | Error> {\n  const convex = useConvexGeneric();\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useQueries` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\"\n    );\n  }\n  const createWatch = useMemo(() => {\n    return (name: string, args: Value[], journal?: QueryJournal) => {\n      return convex.watchQuery(name, args, journal);\n    };\n  }, [convex]);\n  return useQueriesHelper(queries, createWatch);\n}\n\n/**\n * Internal version of `useQueriesGeneric` that is exported for testing.\n */\nexport function useQueriesHelper(\n  queries: RequestForQueries,\n  createWatch: CreateWatch\n): Record<string, any | undefined | Error> {\n  const [observer] = useState(() => new QueriesObserver(createWatch));\n  const [effectRan, setEffectRan] = useState(false);\n\n  if (observer.createWatch !== createWatch) {\n    observer.setCreateWatch(createWatch);\n  }\n\n  // Unsubscribe from all queries on unmount.\n  useEffect(() => {\n    setEffectRan(true);\n    return () => {\n      observer.destroy();\n    };\n  }, [observer]);\n\n  const subscription = useMemo(() => {\n    // Any time the queries change, update our observer.\n    // Correctness notes:\n    // 1. `observer.setQueries` could subscribe us to new queries. They are\n    // cleaned up in `observer.destroy()`, but that may never get called!\n    // React may render a component and then throw it out without running\n    // the effects or their destructors. For satefy, we should only subscribe\n    // if the effects have run and the destructor has been configured.\n    // 2. We're calling this during render so it could happen multiple times!\n    // This is okay though because `setQueries` is written to be idempotent.\n    // 3. When the queries change, we want to immediately return the results of\n    // the new queries. This happens because we recreate the `getCurrentValue`\n    // callback and `useSubscription` re-executes it.\n    if (effectRan) {\n      observer.setQueries(queries);\n    }\n\n    return {\n      getCurrentValue: () => {\n        if (effectRan) {\n          return observer.getCurrentQueries();\n        } else {\n          // If the effect hasn't run yet, our `observer` doesn't have the\n          // current queries. Manually set all the results to `undefined`.\n          // Once the effect runs, we'll rerender and actually pull the results\n          // from the Convex client.\n          const value: Record<string, undefined> = {};\n          for (const identifier in Object.keys(queries)) {\n            value[identifier] = undefined;\n          }\n          return value;\n        }\n      },\n      subscribe: (callback: () => void) => observer.subscribe(callback),\n    };\n  }, [observer, queries, effectRan]);\n\n  return useSubscription(subscription);\n}\n\n/**\n * An object representing a request to load multiple queries.\n *\n * The keys of this object are identifiers and the values are objects containing\n * the name of the query function and the arguments to pass to it.\n *\n * This is used as an argument to {@link useQueriesGeneric}.\n * @public\n */\nexport type RequestForQueries = Record<\n  string,\n  {\n    name: string;\n    args: Value[];\n  }\n>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useQueriesGeneric} a type specific to your API.\n *\n * @public\n */\nexport type UseQueriesForAPI<API extends GenericAPI> = <\n  QueryNameMap extends Record<string, QueryNames<API>>\n>(queries: {\n  [Identifier in keyof QueryNameMap]: {\n    name: QueryNameMap[Identifier];\n    args: Parameters<NamedQuery<API, QueryNameMap[Identifier]>>;\n  };\n}) => {\n  [Identifier in keyof QueryNameMap]:\n    | ReturnType<NamedQuery<API, QueryNameMap[Identifier]>>\n    | undefined\n    | Error;\n};\n"],
  "mappings": ";AACA,SAAS,WAAW,SAAS,gBAAgB;AAC7C,SAAS,wBAAwB;AAEjC,SAAsB,uBAAuB;AAC7C,SAAS,uBAAuB;AAwDzB,gBAAS,kBACd,SACyC;AACzC,QAAM,SAAS,iBAAiB;AAChC,MAAI,WAAW,QAAW;AACxB,UAAM,IAAI;AAAA,MACR;AAAA,IAGF;AAAA,EACF;AACA,QAAM,cAAc,QAAQ,MAAM;AAChC,WAAO,CAAC,MAAc,MAAe,YAA2B;AAC9D,aAAO,OAAO,WAAW,MAAM,MAAM,OAAO;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AACX,SAAO,iBAAiB,SAAS,WAAW;AAC9C;AAKO,gBAAS,iBACd,SACA,aACyC;AACzC,QAAM,CAAC,QAAQ,IAAI,SAAS,MAAM,IAAI,gBAAgB,WAAW,CAAC;AAClE,QAAM,CAAC,WAAW,YAAY,IAAI,SAAS,KAAK;AAEhD,MAAI,SAAS,gBAAgB,aAAa;AACxC,aAAS,eAAe,WAAW;AAAA,EACrC;AAGA,YAAU,MAAM;AACd,iBAAa,IAAI;AACjB,WAAO,MAAM;AACX,eAAS,QAAQ;AAAA,IACnB;AAAA,EACF,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,eAAe,QAAQ,MAAM;AAajC,QAAI,WAAW;AACb,eAAS,WAAW,OAAO;AAAA,IAC7B;AAEA,WAAO;AAAA,MACL,iBAAiB,MAAM;AACrB,YAAI,WAAW;AACb,iBAAO,SAAS,kBAAkB;AAAA,QACpC,OAAO;AAKL,gBAAM,QAAmC,CAAC;AAC1C,qBAAW,cAAc,OAAO,KAAK,OAAO,GAAG;AAC7C,kBAAM,cAAc;AAAA,UACtB;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,WAAW,CAAC,aAAyB,SAAS,UAAU,QAAQ;AAAA,IAClE;AAAA,EACF,GAAG,CAAC,UAAU,SAAS,SAAS,CAAC;AAEjC,SAAO,gBAAgB,YAAY;AACrC;",
  "names": []
}
