{
  "version": 3,
  "sources": ["../../../src/react/use_paginated_query.ts"],
  "sourcesContent": ["import { convexToJson, Value } from \"../values/index.js\";\nimport { useMemo, useState } from \"react\";\nimport { RequestForQueries, useQueriesGeneric } from \"./use_queries.js\";\nimport { GenericAPI, NamedQuery } from \"../api/index.js\";\nimport { OptimisticLocalStore } from \"../browser/index.js\";\nimport { PaginationOptions, PaginationResult } from \"../server/index.js\";\nimport { PickByValue } from \"../type_utils.js\";\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with Convex query functions that match\n * {@link PaginatedQueryFunction}. This means they must:\n * 1. Have a first argument must be an object containing `numItems` and `cursor`.\n * 2. Return a {@link server.PaginationResult}.\n *\n * `usePaginatedQueryGeneric` concatenates all the pages\n * of results into a single list and manages the continuation cursors when\n * requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, loadMore } = usePaginatedQueryGeneric(\n *   \"listMessages\",\n *   { initialNumItems: 5 },\n *   \"#general\"\n * );\n * ```\n *\n * If the query `name` or `args` change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * or QueryScannedTooManyDocuments error, the pagination state will also reset\n * to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/using/pagination).\n *\n * If you're using code generation, use the `usePaginatedQuery` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param name - The name of the query function.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @param args - The arguments to the query function, excluding the first.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQueryGeneric(\n  name: string,\n  options: { initialNumItems: number },\n  ...args: Value[]\n): UsePaginatedQueryResult<any> {\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        name,\n        args,\n        id,\n        maxQueryIndex: 0,\n        queries: {\n          0: {\n            name,\n            args: [\n              {\n                numItems: options.initialNumItems,\n                cursor: null,\n                id,\n              },\n              ...args,\n            ],\n          },\n        },\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(convexToJson(args)), name, options.initialNumItems]);\n\n  const [state, setState] = useState<{\n    name: string;\n    args: Value[];\n    id: number;\n    maxQueryIndex: number;\n    queries: RequestForQueries;\n  }>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    name !== state.name ||\n    JSON.stringify(convexToJson(args)) !==\n      JSON.stringify(convexToJson(state.args))\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueriesGeneric(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (let i = 0; i <= currState.maxQueryIndex; i++) {\n      currResult = resultsObject[i];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (\n          currResult.message.includes(\"InvalidCursor\") ||\n          currResult.message.includes(\"QueryScannedTooManyDocuments\")\n        ) {\n          // `useInifinteQuery` handles a few types of query errors:\n\n          // 1. InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n          // 2. QueryScannedTooManyDocuments: Likely so many elements were\n          // added to a single page they hit our limit.\n\n          // In both cases we want to restart pagination to throw away all our\n          // existing cursors.\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [resultsObject, currState.maxQueryIndex, createInitialState]);\n\n  const statusAndLoadMore = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      return {\n        status: \"LoadingMore\",\n        loadMore: undefined,\n      } as const;\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        loadMore: undefined,\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState(prevState => {\n            const maxQueryIndex = prevState.maxQueryIndex + 1;\n            const queries = { ...prevState.queries };\n            queries[maxQueryIndex] = {\n              name: prevState.name,\n              args: [\n                { numItems, cursor: continueCursor, id: prevState.id },\n                ...prevState.args,\n              ],\n            };\n            return {\n              ...prevState,\n              maxQueryIndex,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult]);\n\n  return {\n    results,\n    ...statusAndLoadMore,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQueryGeneric} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQueryGeneric} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * The result of calling the {@link usePaginatedQueryGeneric} hook.\n *\n * This includes:\n * 1. `results` - An array of the currently loaded results.\n * 2. `status` - The status of the pagination. The possible statuses are:\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * 3. `loadMore` A callback to fetch more results. This will be `undefined`\n * unless the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<T> = {\n  results: T[];\n} & (\n  | {\n      status: \"CanLoadMore\";\n      loadMore: (numItems: number) => void;\n    }\n  | {\n      status: \"LoadingMore\";\n      loadMore: undefined;\n    }\n  | {\n      status: \"Exhausted\";\n      loadMore: undefined;\n    }\n);\n\n/**\n * A query function that is usable with {@link usePaginatedQueryGeneric}.\n *\n * The function's first argument must be a {@link server.PaginationOptions} object.\n * The function must return a {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryFunction<Args extends any[], ReturnType> = (\n  paginationOptions: PaginationOptions,\n  ...args: Args\n) => PaginationResult<ReturnType>;\n\n/**\n * The names of the paginated query functions in a Convex API.\n *\n * These are normal query functions that match {@link PaginatedQueryFunction}.\n *\n * @public\n */\nexport type PaginatedQueryNames<API extends GenericAPI> = keyof PickByValue<\n  API[\"queries\"],\n  PaginatedQueryFunction<any, any>\n> &\n  string;\n\n/**\n * The type of the arguments to a {@link PaginatedQueryFunction}.\n *\n * This type includes all the arguments after the initial\n * {@link server.PaginationOptions} argument.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryFunction<any, any>> =\n  Query extends PaginatedQueryFunction<infer Args, any> ? Args : never;\n\n/**\n * The return type of a {@link PaginatedQueryFunction}.\n *\n * This is the type of the inner document or object within the\n * {@link server.PaginationResult} that a paginated query function returns.\n *\n * @public\n */\nexport type PaginatedQueryReturnType<\n  Query extends PaginatedQueryFunction<any, any>\n> = Query extends PaginatedQueryFunction<any, infer ReturnType>\n  ? ReturnType\n  : never;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link usePaginatedQueryGeneric} a type specific to your API.\n *\n * @public\n */\nexport type UsePaginatedQueryForAPI<API extends GenericAPI> = <\n  Name extends PaginatedQueryNames<API>\n>(\n  name: Name,\n  options: { initialNumItems: number },\n  ...args: PaginatedQueryArgs<NamedQuery<API, Name>>\n) => UsePaginatedQueryResult<PaginatedQueryReturnType<NamedQuery<API, Name>>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQueryGeneric}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(\"myMutationName\")\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     \"paginatedQueryName\",\n *     [],\n *     currentValue => {\n *       if (mutationArg.equals(currentValue._id)) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param name - The name of the paginated query function.\n * @param args - The arguments to the query function, excluding the first.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  API extends GenericAPI,\n  Name extends PaginatedQueryNames<API>\n>(\n  localStore: OptimisticLocalStore<API>,\n  name: Name,\n  args: PaginatedQueryArgs<NamedQuery<API, Name>>,\n  updateValue: (\n    currentValue: PaginatedQueryReturnType<NamedQuery<API, Name>>\n  ) => PaginatedQueryReturnType<NamedQuery<API, Name>>\n): void {\n  // TODO(CX-749): This should really be sorted JSON or an `equals` method\n  // so that the order of properties in sets, maps, and objects doesn't break\n  // our comparison.\n  const expectedArgs = JSON.stringify(convexToJson(args));\n\n  for (const query of localStore.getAllQueries(name)) {\n    if (\n      query.value !== undefined &&\n      query.args.length >= 1 &&\n      JSON.stringify(convexToJson(query.args.slice(1))) === expectedArgs\n    ) {\n      const value = query.value;\n      if (\n        typeof value === \"object\" &&\n        value !== null &&\n        Array.isArray(value.page)\n      ) {\n        localStore.setQuery(name, query.args, {\n          ...value,\n          page: value.page.map(updateValue),\n        });\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
