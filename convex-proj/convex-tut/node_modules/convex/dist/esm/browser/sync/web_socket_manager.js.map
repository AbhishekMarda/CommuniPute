{
  "version": 3,
  "sources": ["../../../../src/browser/sync/web_socket_manager.ts"],
  "sourcesContent": ["import {\n  ClientMessage,\n  parseServerMessage,\n  ServerMessage,\n} from \"./protocol.js\";\n\nconst CLOSE_NORMAL = 1000;\nconst CLOSE_NO_STATUS = 1005;\n\ntype PromisePair<T> = { promise: Promise<T>; resolve: (value: T) => void };\n\n/**\n * The various states our WebSocket can be in:\n *\n * - \"disconnected\": We don't have a WebSocket, but plan to create one.\n * - \"connecting\": We have created the WebSocket and are waiting for the\n *   `onOpen` callback.\n * - \"ready\": We have an open WebSocket.\n * - \"closing\": We called `.close()` on the WebSocket and are waiting for the\n *   `onClose` callback before we schedule a reconnect.\n * - \"stopping\": The application decided to totally stop the WebSocket. We are\n *    waiting for the `onClose` callback before we consider this WebSocket stopped.\n * - \"pausing\": The client needs to fetch some data before it makes sense to resume\n *    the WebSocket connection.\n * - \"paused\": The WebSocket was stopped and a new one can be created via `.resume()`.\n * - \"stopped\": We have stopped the WebSocket and will never create a new one.\n *\n *\n * WebSocket State Machine\n * -----------------------\n * initialState: disconnected\n * validTransitions:\n *   disconnected:\n *     new WebSocket() -> connecting\n *     stop() -> stopped\n *   connecting:\n *     onopen -> ready\n *     close() -> closing\n *     stop() -> stopping\n *   ready:\n *     close() -> closing\n *     pause() -> pausing\n *     stop() -> stopping\n *   closing:\n *     onclose -> disconnected\n *     stop() -> stopping\n *   pausing:\n *     onclose -> paused\n *     stop() -> stopping\n *   paused:\n *     resume() -> connecting\n *     stop() -> stopped\n *   stopping:\n *     onclose -> stopped\n * terminalStates:\n *   stopped\n */\ntype Socket =\n  | { state: \"disconnected\" }\n  | { state: \"connecting\"; ws: WebSocket }\n  | { state: \"ready\"; ws: WebSocket }\n  | { state: \"closing\" }\n  | { state: \"pausing\"; promisePair: PromisePair<null> }\n  | { state: \"paused\" }\n  | { state: \"stopping\"; promisePair: PromisePair<null> }\n  | { state: \"stopped\" };\n\nfunction promisePair<T>(): PromisePair<T> {\n  let resolvePromise: (value: T) => void;\n  const promise = new Promise<T>(resolve => {\n    resolvePromise = resolve;\n  });\n  return { promise, resolve: resolvePromise! };\n}\n\nexport type ReconnectMetadata = {\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\n/**\n * A wrapper around a websocket that handles errors, reconnection, and message\n * parsing.\n */\nexport class WebSocketManager {\n  private socket: Socket;\n\n  private connectionCount: number;\n  private lastCloseReason: string | null;\n\n  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n  private readonly initialBackoff: number;\n\n  /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n  private readonly maxBackoff: number;\n\n  /** How many times have we failed consecutively? */\n  private retries: number;\n\n  /** How long before lack of server response causes us to initiate a reconnect,\n   * in ms */\n  private readonly serverInactivityThreshold: number;\n\n  private reconnectDueToServerInactivityTimeout: ReturnType<\n    typeof setTimeout\n  > | null;\n\n  private readonly uri: string;\n  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n  private readonly onMessage: (message: ServerMessage) => void;\n  private readonly webSocketConstructor: typeof WebSocket;\n\n  constructor(\n    uri: string,\n    onOpen: (reconnectMetadata: ReconnectMetadata) => void,\n    onMessage: (message: ServerMessage) => void,\n    webSocketConstructor: typeof WebSocket\n  ) {\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n\n    this.initialBackoff = 100;\n    this.maxBackoff = 16000;\n    this.retries = 0;\n\n    this.serverInactivityThreshold = 30000;\n    this.reconnectDueToServerInactivityTimeout = null;\n\n    this.uri = uri;\n    this.onOpen = onOpen;\n    this.onMessage = onMessage;\n\n    // Kick off connection but don't wait for it.\n    void this.connect();\n  }\n\n  private async connect() {\n    if (\n      this.socket.state === \"closing\" ||\n      this.socket.state === \"stopping\" ||\n      this.socket.state === \"stopped\"\n    ) {\n      return;\n    }\n    if (\n      this.socket.state !== \"disconnected\" &&\n      this.socket.state !== \"paused\"\n    ) {\n      throw new Error(\"Didn't start connection from disconnected state\");\n    }\n\n    const ws = new this.webSocketConstructor(this.uri);\n    this.socket = {\n      state: \"connecting\",\n      ws,\n    };\n    ws.onopen = () => {\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = { state: \"ready\", ws };\n      this.onServerActivity();\n      this.onOpen({\n        connectionCount: this.connectionCount,\n        lastCloseReason: this.lastCloseReason,\n      });\n\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.\n    ws.onerror = error => {\n      const message = (error as ErrorEvent).message;\n      console.log(`WebSocket error: ${message}`);\n      this.closeAndReconnect(\"WebSocketError\");\n    };\n    ws.onmessage = message => {\n      // TODO(CX-1498): We reset the retry counter on any successful message.\n      // This is not ideal and we should improve this further.\n      this.retries = 0;\n      this.onServerActivity();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this.onMessage(serverMessage);\n    };\n    ws.onclose = event => {\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_NO_STATUS) {\n        let msg = `WebSocket closed unexpectedly with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.error(msg);\n      }\n      if (this.socket.state === \"stopping\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"stopped\" };\n        return;\n      }\n      if (this.socket.state === \"pausing\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"paused\" };\n        return;\n      }\n      this.socket = { state: \"disconnected\" };\n      const backoff = this.nextBackoff();\n      console.log(`Attempting reconnect in ${backoff}ms`);\n      setTimeout(() => this.connect(), backoff);\n    };\n  }\n\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState(): string {\n    return this.socket.state;\n  }\n\n  sendMessage(message: ClientMessage) {\n    if (this.socket.state === \"ready\") {\n      const request = JSON.stringify(message);\n      try {\n        this.socket.ws.send(request);\n      } catch (error: any) {\n        console.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n    }\n  }\n\n  private onServerActivity() {\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n\n  /**\n   * Close the WebSocket and schedule a reconnect when it completes closing.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  private closeAndReconnect(closeReason: string) {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"closing\":\n      case \"stopping\":\n      case \"stopped\":\n      case \"pausing\":\n      case \"paused\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.lastCloseReason = closeReason;\n        this.socket.ws.close();\n        this.socket = {\n          state: \"closing\",\n        };\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  async stop(): Promise<void> {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"stopped\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"pausing\":\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"stopping\" so we don't reconnect.\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"paused\":\n      case \"disconnected\":\n        // If we're disconnected so switch the state to \"stopped\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        // If we're paused prevent a resume.\n        this.socket = { state: \"stopped\" };\n        return;\n      case \"stopping\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  async pause(): Promise<void> {\n    switch (this.socket.state) {\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore pause\n        return;\n      case \"paused\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"pausing\" so we don't reconnect.\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"disconnected\":\n        // We're disconnected so switch the state to \"paused\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        this.socket = { state: \"paused\" };\n        return;\n      case \"pausing\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Create a new WebSocket after a previous `pause()`, unless `stop()` was\n   * called before.\n   */\n  async resume(): Promise<void> {\n    switch (this.socket.state) {\n      case \"pausing\":\n      case \"paused\":\n        break;\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore resume\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"closing\":\n      case \"disconnected\":\n        throw new Error(\"`resume()` is only valid after `pause()`\");\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    if (this.socket.state === \"pausing\") {\n      await this.socket.promisePair.promise;\n    }\n    await this.connect();\n  }\n\n  private nextBackoff(): number {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
