{
  "version": 3,
  "sources": ["../../../../src/browser/sync/udf_path_utils.ts"],
  "sourcesContent": ["import { convexToJson } from \"../../values/index.js\";\n\nexport function canonicalizeUdfPath(udfPath: string): string {\n  const pieces = udfPath.split(\":\");\n  let moduleName: string;\n  let functionName: string;\n  if (pieces.length === 1) {\n    moduleName = pieces[0];\n    functionName = \"default\";\n  } else {\n    moduleName = pieces.slice(0, pieces.length - 1).join(\":\");\n    functionName = pieces[pieces.length - 1];\n  }\n  if (!moduleName.endsWith(\".js\")) {\n    moduleName = `${moduleName}.js`;\n  }\n  return `${moduleName}:${functionName}`;\n}\n\n/**\n * A string representing the name and arguments of a query.\n *\n * This is used by the {@link InternalConvexClient}.\n *\n * @public\n */\nexport type QueryToken = string;\n\n// TODO(CX-749): Make this a unique representation (sort sets, dicts, objects)\nexport function serializePathAndArgs(udfPath: string, args: any[]): QueryToken {\n  return JSON.stringify({\n    udfPath: canonicalizeUdfPath(udfPath),\n    args: convexToJson(args),\n  });\n}\n"],
  "mappings": ";AAAA,SAAS,oBAAoB;AAEtB,gBAAS,oBAAoB,SAAyB;AAC3D,QAAM,SAAS,QAAQ,MAAM,GAAG;AAChC,MAAI;AACJ,MAAI;AACJ,MAAI,OAAO,WAAW,GAAG;AACvB,iBAAa,OAAO;AACpB,mBAAe;AAAA,EACjB,OAAO;AACL,iBAAa,OAAO,MAAM,GAAG,OAAO,SAAS,CAAC,EAAE,KAAK,GAAG;AACxD,mBAAe,OAAO,OAAO,SAAS;AAAA,EACxC;AACA,MAAI,CAAC,WAAW,SAAS,KAAK,GAAG;AAC/B,iBAAa,GAAG;AAAA,EAClB;AACA,SAAO,GAAG,cAAc;AAC1B;AAYO,gBAAS,qBAAqB,SAAiB,MAAyB;AAC7E,SAAO,KAAK,UAAU;AAAA,IACpB,SAAS,oBAAoB,OAAO;AAAA,IACpC,MAAM,aAAa,IAAI;AAAA,EACzB,CAAC;AACH;",
  "names": []
}
