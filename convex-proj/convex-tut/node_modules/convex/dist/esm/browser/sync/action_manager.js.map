{
  "version": 3,
  "sources": ["../../../../src/browser/sync/action_manager.ts"],
  "sourcesContent": ["import { ActionRequest, ActionResponse, RequestId } from \"./protocol.js\";\nimport { jsonToConvex } from \"../../values/index.js\";\nimport { createError, logToConsole } from \"../logging.js\";\n\ntype ActionStatus = {\n  message: ActionRequest;\n  onResult: (result: any) => void;\n  onFailure: (reason: any) => void;\n};\n\nexport class ActionManager {\n  private inflightActions: Map<RequestId, ActionStatus>;\n\n  constructor() {\n    this.inflightActions = new Map();\n  }\n\n  request(message: ActionRequest): Promise<any> {\n    const result = new Promise((resolve, reject) => {\n      this.inflightActions.set(message.requestId, {\n        message,\n        onResult: resolve,\n        onFailure: reject,\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a action response.\n   */\n  onResponse(response: ActionResponse) {\n    const actionInfo = this.inflightActions.get(response.requestId);\n    if (actionInfo === undefined) {\n      // Got a response of a message that we don't know about. That shouldn't\n      // really happen unless we get duplicate messages or something.\n      return;\n    }\n\n    this.inflightActions.delete(response.requestId);\n    const udfPath = actionInfo.message.udfPath;\n    for (const line of response.logLines) {\n      logToConsole(\"info\", \"action\", udfPath, line);\n    }\n    if (response.success) {\n      actionInfo.onResult(jsonToConvex(response.result));\n    } else {\n      logToConsole(\"error\", \"action\", udfPath, response.result);\n      actionInfo.onFailure(createError(\"action\", udfPath, response.result));\n    }\n  }\n\n  hasInflightActions(): boolean {\n    return this.inflightActions.size > 0;\n  }\n\n  restart() {\n    // Unlike mutations, actions are not idempotent. When we reconnect to the\n    // backend, we don't know if it is safe to resend in-flight actions, so we\n    // cancel them and consider them failed.\n    // TODO(presley): If we make the server remember it has started executing a\n    // function, we can resend here and remove browser to backend connectivity as\n    // a source of transient errors. For example, if a function has never reached\n    // the server, then we can safely execute it. If a function was executed\n    // successfully but response didn't reach the client. Server can return\n    // success on reconnect.\n    for (const [actionId, actionInfo] of this.inflightActions) {\n      this.inflightActions.delete(actionId);\n      const udfPath = actionInfo.message.udfPath;\n      actionInfo.onFailure(createError(\"action\", udfPath, \"Transient error\"));\n    }\n  }\n}\n"],
  "mappings": ";AACA,SAAS,oBAAoB;AAC7B,SAAS,aAAa,oBAAoB;AAQnC,aAAM,cAAc;AAAA,EAGzB,cAAc;AACZ,SAAK,kBAAkB,oBAAI,IAAI;AAAA,EACjC;AAAA,EAEA,QAAQ,SAAsC;AAC5C,UAAM,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC9C,WAAK,gBAAgB,IAAI,QAAQ,WAAW;AAAA,QAC1C;AAAA,QACA,UAAU;AAAA,QACV,WAAW;AAAA,MACb,CAAC;AAAA,IACH,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAKA,WAAW,UAA0B;AACnC,UAAM,aAAa,KAAK,gBAAgB,IAAI,SAAS,SAAS;AAC9D,QAAI,eAAe,QAAW;AAG5B;AAAA,IACF;AAEA,SAAK,gBAAgB,OAAO,SAAS,SAAS;AAC9C,UAAM,UAAU,WAAW,QAAQ;AACnC,eAAW,QAAQ,SAAS,UAAU;AACpC,mBAAa,QAAQ,UAAU,SAAS,IAAI;AAAA,IAC9C;AACA,QAAI,SAAS,SAAS;AACpB,iBAAW,SAAS,aAAa,SAAS,MAAM,CAAC;AAAA,IACnD,OAAO;AACL,mBAAa,SAAS,UAAU,SAAS,SAAS,MAAM;AACxD,iBAAW,UAAU,YAAY,UAAU,SAAS,SAAS,MAAM,CAAC;AAAA,IACtE;AAAA,EACF;AAAA,EAEA,qBAA8B;AAC5B,WAAO,KAAK,gBAAgB,OAAO;AAAA,EACrC;AAAA,EAEA,UAAU;AAUR,eAAW,CAAC,UAAU,UAAU,KAAK,KAAK,iBAAiB;AACzD,WAAK,gBAAgB,OAAO,QAAQ;AACpC,YAAM,UAAU,WAAW,QAAQ;AACnC,iBAAW,UAAU,YAAY,UAAU,SAAS,iBAAiB,CAAC;AAAA,IACxE;AAAA,EACF;AACF;",
  "names": []
}
