/**
 * @jest-environment jsdom
 */

import { test, expect, jest } from "@jest/globals";
import { renderHook } from "@testing-library/react-hooks";
import {
  PaginatedQueryArgs,
  PaginatedQueryReturnType,
  usePaginatedQueryGeneric,
} from "./use_paginated_query";
import { ConvexProvider, ConvexReactClient } from "./index.js";
import { Value } from "../values";
import { assert, Equals } from "../test/type_testing.js";
import { PaginationOptions, PaginationResult } from "../server";

const address = "https://localhost:3001";

test("Initially returns LoadingMore", () => {
  const convexClient = new ConvexReactClient(address);
  const watchQuerySpy = jest.spyOn(convexClient, "watchQuery");
  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <ConvexProvider client={convexClient}>{children}</ConvexProvider>
  );

  const { result } = renderHook(
    () => usePaginatedQueryGeneric("myQuery", { initialNumItems: 10 }),
    { wrapper }
  );

  expect(watchQuerySpy.mock.calls).toEqual([
    [
      "myQuery",
      [{ cursor: null, id: expect.anything(), numItems: 10 }],
      undefined,
    ],
  ]);
  expect(result.current).toStrictEqual({
    loadMore: undefined,
    results: [],
    status: "LoadingMore",
  });
});

test("Updates to a new query if query name or args change", () => {
  const convexClient = new ConvexReactClient(address);
  const watchQuerySpy = jest.spyOn(convexClient, "watchQuery");

  let args: [
    name: string,
    options: { initialNumItems: number },
    ...args: Value[]
  ] = ["myQuery", { initialNumItems: 10 }];
  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <ConvexProvider client={convexClient}>{children}</ConvexProvider>
  );

  const { rerender } = renderHook(() => usePaginatedQueryGeneric(...args), {
    wrapper,
  });

  // Starts with just the initial query.
  expect(watchQuerySpy.mock.calls.length).toBe(1);
  expect(watchQuerySpy.mock.calls[0]).toEqual([
    "myQuery",
    [{ cursor: null, id: expect.anything(), numItems: 10 }],
    undefined,
  ]);

  // If we change the query name, we get a new call.
  args = ["myQuery2", { initialNumItems: 10 }];
  rerender();
  expect(watchQuerySpy.mock.calls.length).toBe(2);
  expect(watchQuerySpy.mock.calls[1]).toEqual([
    "myQuery2",
    [{ cursor: null, id: expect.anything(), numItems: 10 }],
    undefined,
  ]);

  // If we add an arg, it also updates.
  args = ["myQuery2", { initialNumItems: 10 }, { someArg: 123 }];
  rerender();
  expect(watchQuerySpy.mock.calls.length).toBe(3);
  expect(watchQuerySpy.mock.calls[2]).toEqual([
    "myQuery2",
    [{ cursor: null, id: expect.anything(), numItems: 10 }, { someArg: 123 }],
    undefined,
  ]);

  // Updating to a new arg object that serializes the same thing doesn't increase
  // the all count.
  args = ["myQuery2", { initialNumItems: 10 }, { someArg: 123 }];
  rerender();
  expect(watchQuerySpy.mock.calls.length).toBe(3);
});

describe("PaginatedQueryArgs", () => {
  test("optional arg", () => {
    type MyQueryFunction = (
      opts: PaginationOptions,
      arg?: string
    ) => PaginationResult<string>;
    type Args = PaginatedQueryArgs<MyQueryFunction>;
    type ExpectedArgs = [arg?: string];
    assert<Equals<Args, ExpectedArgs>>();
  });

  test("interface arg", () => {
    interface Arg {
      property: string;
    }
    type MyQueryFunction = (
      opts: PaginationOptions,
      arg: Arg
    ) => PaginationResult<string>;
    type Args = PaginatedQueryArgs<MyQueryFunction>;
    type ExpectedArgs = [arg: Arg];
    assert<Equals<Args, ExpectedArgs>>();
  });
});

describe("PaginatedQueryReturnType", () => {
  test("interface return type", () => {
    interface ReturnType {
      property: string;
    }
    type MyQueryFunction = (
      opts: PaginationOptions
    ) => PaginationResult<ReturnType>;
    type ActualReturnType = PaginatedQueryReturnType<MyQueryFunction>;
    assert<Equals<ActualReturnType, ReturnType>>();
  });
});
