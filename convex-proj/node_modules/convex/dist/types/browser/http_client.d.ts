import { ActionNames, GenericAPI, MutationNames, NamedAction, NamedMutation, NamedQuery, QueryNames } from "../api/index.js";
/**
 * An interface to execute a Convex query function on the server.
 *
 * @public
 */
export interface Query<F extends (...args: any[]) => Promise<any>> {
    /**
     * Execute the query on the server, returning a `Promise` of the return value.
     *
     * @param args - Arguments for the query.
     * @returns The result of the query.
     */
    (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;
}
/**
 * An interface to execute a Convex mutation function on the server.
 *
 * @public
 */
export interface Mutation<F extends (...args: any[]) => Promise<any>> {
    /**
     * Execute the mutation on the server, returning a `Promise` of its return value.
     *
     * @param args - Arguments for the mutation.
     * @returns The return value of the server-side function call.
     */
    (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;
}
/**
 * An interface to execute a Convex action on the server.
 *
 * @internal
 */
export interface Action<F extends (...args: any[]) => Promise<any>> {
    /**
     * Execute the action on the server, returning a `Promise` of its return value.
     *
     * @param args - Arguments for the action.
     * @returns The return value of the server-side action call.
     */
    (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;
}
/**
 * A Convex client that runs queries and mutations over HTTP.
 *
 * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive
 * webapps.
 *
 * If you're building a React app, consider using
 * {@link react.ConvexReactClient} instead.
 *
 *
 * @public
 */
export declare class ConvexHttpClient<API extends GenericAPI> {
    private readonly address;
    private auth?;
    private debug;
    constructor(address: string);
    /**
     * Obtain the {@link ConvexHttpClient}'s URL to its backend.
     *
     * @returns The URL to the Convex backend, including the client's API version.
     */
    backendUrl(): string;
    /**
     * Set the authentication token to be used for subsequent queries and mutations.
     *
     * Should be called whenever the token changes (i.e. due to expiration and refresh).
     *
     * @param value - JWT-encoded OpenID Connect identity token.
     */
    setAuth(value: string): void;
    /**
     * Clear the current authentication token if set.
     */
    clearAuth(): void;
    /**
     * Sets whether the result log lines should be printed on the console or not.
     *
     * @internal
     */
    setDebug(debug: boolean): void;
    /**
     * Construct a new {@link Query}.
     *
     * @param name - The name of the query function.
     * @returns The {@link Query} object with that name.
     */
    query<Name extends QueryNames<API>>(name: Name): (...args: Parameters<NamedQuery<API, Name>>) => Promise<ReturnType<NamedQuery<API, Name>>>;
    /**
     * Construct a new {@link Mutation}.
     *
     * @param name - The name of the mutation function.
     * @returns The {@link Mutation} object with that name.
     */
    mutation<Name extends MutationNames<API>>(name: Name): (...args: Parameters<NamedMutation<API, Name>>) => Promise<ReturnType<NamedMutation<API, Name>>>;
    /**
     * Construct a new {@link Action}.
     *
     * @param name - The name of the action.
     * @returns The {@link Action} object with that name.
     * @public
     */
    action<Name extends ActionNames<API>>(name: Name): (...args: Parameters<NamedAction<API, Name>>) => Promise<ReturnType<NamedAction<API, Name>>>;
}
//# sourceMappingURL=http_client.d.ts.map