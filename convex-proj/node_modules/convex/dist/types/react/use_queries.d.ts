import { Value } from "../values/index.js";
import { GenericAPI, NamedQuery, QueryNames } from "../api/index.js";
import { CreateWatch } from "./queries_observer.js";
/**
 * Load a variable number of reactive Convex queries.
 *
 * `useQueriesGeneric` is similar to {@link useQueryGeneric} but it allows
 * loading multiple queries which can be useful for loading a dynamic number
 * of queries without violating the rules of React hooks.
 *
 * This hook accepts an object whose keys are identifiers for each query and the
 * values are objects of `{ name: string, args: Value[] }`. The `name` is the
 * name of the Convex query function to load, and the `args` are the arguments to
 * that function.
 *
 * The hook returns an object that maps each identifier to the result of the query,
 * `undefined` if the query is still loading, or an instance of `Error` if the query
 * threw an exception.
 *
 * For example if you loaded a query like:
 * ```typescript
 * const results = useQueriesGeneric({
 *   messagesInGeneral: {
 *     name: "listMessages",
 *     args: ["#general"]
 *   }
 * });
 * ```
 * then the result would look like:
 * ```typescript
 * {
 *   messagesInGeneral: [{
 *     channel: "#general",
 *     body: "hello"
 *     _id: ...,
 *     _creationTime: ...
 *   }]
 * }
 * ```
 *
 * This React hook contains internal state that will cause a rerender
 * whenever any of the query results change.
 *
 * Throws an error if not used under {@link ConvexProvider}.
 *
 * If you're using code generation, use the `useQueries` function in
 * `convex/_generated/react.js` which is typed for your API.
 *
 * @param queries - An object mapping identifiers to objects of
 * `{name: string, args: Value[] }` describing which query functions to fetch.
 * @returns An object with the same keys as the input. The values are the result
 * of the query function, `undefined` if it's still loading, or an `Error` if
 * it threw an exception.
 *
 * @public
 */
export declare function useQueriesGeneric(queries: RequestForQueries): Record<string, any | undefined | Error>;
/**
 * Internal version of `useQueriesGeneric` that is exported for testing.
 */
export declare function useQueriesHelper(queries: RequestForQueries, createWatch: CreateWatch): Record<string, any | undefined | Error>;
/**
 * An object representing a request to load multiple queries.
 *
 * The keys of this object are identifiers and the values are objects containing
 * the name of the query function and the arguments to pass to it.
 *
 * This is used as an argument to {@link useQueriesGeneric}.
 * @public
 */
export declare type RequestForQueries = Record<string, {
    name: string;
    args: Value[];
}>;
/**
 * Internal type helper used by Convex code generation.
 *
 * Used to give {@link useQueriesGeneric} a type specific to your API.
 *
 * @public
 */
export declare type UseQueriesForAPI<API extends GenericAPI> = <QueryNameMap extends Record<string, QueryNames<API>>>(queries: {
    [Identifier in keyof QueryNameMap]: {
        name: QueryNameMap[Identifier];
        args: Parameters<NamedQuery<API, QueryNameMap[Identifier]>>;
    };
}) => {
    [Identifier in keyof QueryNameMap]: ReturnType<NamedQuery<API, QueryNameMap[Identifier]>> | undefined | Error;
};
//# sourceMappingURL=use_queries.d.ts.map