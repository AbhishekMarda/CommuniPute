/**
 * The names of actions in a Convex API.
 *
 * @public
 */
export declare type ActionNames<API extends GenericAPI> = keyof API["actions"] & string;

/**
 * Create the API type from the types of all of the modules.
 *
 * Input is an object mapping file paths to the type of each module.
 *
 * For internal use by Convex code generation.
 *
 * @public
 */
export declare type ApiFromModules<Modules extends Record<string, Record<string, any>>> = {
    queries: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isQuery: true;
    }>>>;
    mutations: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isMutation: true;
    }>>>;
    actions: Expand<ConvertToClientFunctions<PickByValue<MergeAllExports<Modules>, {
        isAction: true;
    }>>>;
};

/**
 * Converts a map of query and mutation types into their client form.
 *
 * This is done by:
 * - Unwrapping `Promise` if it's in the output.
 * - Switching functions that output `undefined` to `null`.
 *
 */
declare type ConvertToClientFunctions<FunctionsByName extends Record<string, any>> = {
    [Name in keyof FunctionsByName]: (...args: FunctionsByName[Name]["args"]) => UndefinedToNull<Awaited<FunctionsByName[Name]["output"]>>;
};

/**
 * Common utilities for manipulating TypeScript types.
 * @module
 */
/**
 * Hack! This type causes TypeScript to simplify how it renders object types.
 *
 * It is functionally the identity for object types, but in practice it can
 * simplify expressions like `A & B`.
 */
declare type Expand<ObjectType extends Record<any, any>> = ObjectType extends Record<any, any> ? {
    [Key in keyof ObjectType]: ObjectType[Key];
} : never;

/**
 * Internal Codegen Type Helpers
 */
/**
 * Generate the fully-qualified query/mutation name of an export.
 *
 * This is `path/to/module:export` or `path/to/module` for the default export.
 */
declare type FunctionName<FilePath extends string, ExportName extends string> = ExportName extends "default" ? FilePath : `${FilePath}:${ExportName}`;

/**
 * Description of the Convex functions available to an application.
 *
 * This is a generic type that expresses the shape of API types created by
 * `npx convex codegen`. It's used to make the Convex clients type-safe.
 *
 * @public
 */
export declare type GenericAPI = {
    queries: Record<string, (...args: any[]) => any>;
    mutations: Record<string, (...args: any[]) => any>;
    actions: Record<string, (...args: any[]) => any>;
};

/**
 * Name and merge together all of the exports in the `convex/` directory into
 * a flat object type.
 */
declare type MergeAllExports<Modules extends Record<string, Record<string, any>>> = UnionToIntersection<{
    [FilePath in keyof Modules]: NameModule<FilePath & string, Modules[FilePath]>;
}[keyof Modules]>;

/**
 * The names of mutation functions in a Convex API.
 *
 * @public
 */
export declare type MutationNames<API extends GenericAPI> = keyof API["mutations"] & string;

/**
 * The type of an action in a Convex API.
 *
 * @public
 */
export declare type NamedAction<API extends GenericAPI, Name extends MutationNames<API>> = API["actions"][Name];

/**
 * The type of a mutation function in a Convex API.
 *
 * @public
 */
export declare type NamedMutation<API extends GenericAPI, Name extends MutationNames<API>> = API["mutations"][Name];

/**
 * The type of a query function in a Convex API.
 *
 * @public
 */
export declare type NamedQuery<API extends GenericAPI, Name extends QueryNames<API>> = API["queries"][Name];

/**
 * Generate a type of this module where each export is renamed to its
 * fully-qualified {@link FunctionName}.
 */
declare type NameModule<FilePath extends string, Module extends Record<string, any>> = {
    [ExportName in keyof Module as FunctionName<FilePath, ExportName & string>]: Module[ExportName];
};

/**
 * From ObjectType, pick the properties that are assignable to T.
 */
declare type PickByValue<ObjectType, T> = Pick<ObjectType, {
    [Key in keyof ObjectType]: ObjectType[Key] extends T ? Key : never;
}[keyof ObjectType]>;

/**
 * Helper types for interacting with the overall API type
 */
/**
 * The names of query functions in a Convex API.
 *
 * @public
 */
export declare type QueryNames<API extends GenericAPI> = keyof API["queries"] & string;

declare type UndefinedToNull<T> = T extends void ? null : T;

/**
 * Convert a union type like `A | B | C` into an intersection type like
 * `A & B & C`.
 */
declare type UnionToIntersection<UnionType> = (UnionType extends any ? (k: UnionType) => void : never) extends (k: infer I) => void ? I : never;

export { }
