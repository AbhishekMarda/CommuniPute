{
  "version": 3,
  "sources": ["../../../src/server/router.ts"],
  "sourcesContent": ["import { setupAuth } from \"./impl/authentication_impl.js\";\nimport { setupHttpCalls } from \"./impl/http_impl.js\";\nimport { performJsSyscall } from \"./impl/syscall.js\";\nimport { PublicHttpEndpoint } from \"./registration.js\";\n\n// HEAD is handled by Convex by running GET and stripping the body.\n// CONNECT is not supported and will not be supported.\n// TRACE is not supported and will not be supported.\nconst routableMethods = [\n  \"GET\",\n  \"POST\",\n  \"PUT\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"PATCH\",\n] as const;\ntype RoutableMethod = typeof routableMethods[number];\n\nfunction normalizeMethod(method: RoutableMethod | \"HEAD\"): RoutableMethod {\n  // This router routes HEAD requests as GETs, letting Axum strip thee response\n  // bodies are response bodies afterward.\n  if (method === \"HEAD\") return \"GET\";\n  return method;\n}\n\n/**\n * Return a new {@link HttpRouter} object.\n *\n * @public\n */\nexport const httpRouter = () => new HttpRouter();\n\ntype RouteSpec =\n  | {\n      path: string;\n      method: RoutableMethod;\n      handler: PublicHttpEndpoint<any>;\n    }\n  | {\n      pathPrefix: string;\n      method: RoutableMethod;\n      handler: PublicHttpEndpoint<any>;\n    };\n\n/**\n * HTTP router for specifying the paths and methods of {@link httpEndpointGeneric}s\n *\n * An example `convex/http.js` file might look like this.\n *\n * ```js\n * import { httpRouter } from \"./_generated/server\";\n * import { getMessagesByAuthor } from \"./getMessagesByAuthor\";\n * import { httpEndpoint } from \"./_generated/server\";\n *\n * const http = httpRouter();\n *\n * // HTTP endpoints can be defined inline...\n * http.route({\n *   path: \"/message\",\n *   method: \"POST\",\n *   handler: httpEndpoint(async ({ runMutation }, request) => {\n *     const { author, body } = await request.json();\n *\n *     await runMutation(\"sendMessage\", body, author);\n *     return new Response(null, {\n *       status: 200,\n *     });\n *   })\n * });\n *\n * // ...or they can be imported from other files.\n * http.route({\n *   path: \"/getMessagesByAuthor\",\n *   method: \"GET\",\n *   handler: getMessagesByAuthor,\n * });\n *\n * // Convex expects the router to be the default export of `convex/http.js`.\n * export default http;\n * ```\n *\n * @public\n */\nexport class HttpRouter {\n  exactRoutes: Map<string, Map<RoutableMethod, PublicHttpEndpoint<any>>> =\n    new Map();\n  prefixRoutes: Map<RoutableMethod, Map<string, PublicHttpEndpoint<any>>> =\n    new Map();\n  isRouter = true;\n\n  /**\n   * Specify an HttpEndpoint to be used to respond to requests\n   * for an HTTP method (e.g. \"GET\") and a path or pathPrefix.\n   *\n   * Paths must begin with a slash. Path prefixes must also end in a slash.\n   *\n   * ```js\n   * // matches `/profile` (but not `/profile/`)\n   * http.route({ path: \"/profile\", method: \"GET\", handler: getProfile})\n   *\n   * // matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)\n   * http.route({ pathPrefix: \"/profile/\", method: \"GET\", handler: getProfile})\n   * ```\n   * @returns - an array of [path, route, endpoints] tuples.\n   */\n  route = (spec: RouteSpec) => {\n    if (!spec.handler) throw new Error(`route requires handler`);\n    if (!spec.method) throw new Error(`route requires method`);\n    const { method, handler } = spec;\n    if (!routableMethods.includes(method)) {\n      throw new Error(\n        `'${method}' is not an allowed HTTP method (like GET, POST, PUT etc.)`\n      );\n    }\n\n    if (\"path\" in spec) {\n      if (!spec.path.startsWith(\"/\")) {\n        throw new Error(`path '${spec.path}' does not start with a /`);\n      }\n      const prefixes =\n        this.prefixRoutes.get(method) ||\n        new Map<string, PublicHttpEndpoint<any>>();\n      for (const [prefix, _] of prefixes.entries()) {\n        if (spec.path.startsWith(prefix)) {\n          throw new Error(\n            `${spec.method} path ${spec.path} is shadowed by pathPrefix ${prefix}`\n          );\n        }\n      }\n      const methods: Map<\n        RoutableMethod,\n        PublicHttpEndpoint<any>\n      > = this.exactRoutes.has(spec.path)\n        ? this.exactRoutes.get(spec.path)!\n        : new Map();\n      if (methods.has(method)) {\n        throw new Error(\n          `Path '${spec.path}' for method ${method} already in use`\n        );\n      }\n      methods.set(method, handler);\n      this.exactRoutes.set(spec.path, methods);\n    } else {\n      if (!spec.pathPrefix.startsWith(\"/\")) {\n        throw new Error(`path '${spec.pathPrefix}' does not start with a /`);\n      }\n      if (!spec.pathPrefix.endsWith(\"/\")) {\n        throw new Error(`pathPrefix ${spec.pathPrefix} must end with a /`);\n      }\n      const prefixes =\n        this.prefixRoutes.get(method) ||\n        new Map<string, PublicHttpEndpoint<any>>();\n      for (const [prefix, _] of prefixes.entries()) {\n        if (spec.pathPrefix.startsWith(prefix)) {\n          throw new Error(\n            `${spec.method} pathPrefix ${spec.pathPrefix} is shadowed by pathPrefix ${prefix}`\n          );\n        }\n      }\n      prefixes.set(spec.pathPrefix, handler);\n      this.prefixRoutes.set(method, prefixes);\n    }\n  };\n\n  /**\n   * Returns a list of routed HTTP endpoints.\n   *\n   * @returns - an array of [path, route, endpoints] tuples.\n   */\n  getRoutes = () => {\n    const exactPaths: string[] = [...this.exactRoutes.keys()].sort();\n    const exact = exactPaths.flatMap(path =>\n      [...this.exactRoutes.get(path)!.keys()]\n        .sort()\n        .map(\n          method =>\n            [path, method, this.exactRoutes.get(path)!.get(method)!] as const\n        )\n    );\n\n    const prefixPathMethods = [...this.prefixRoutes.keys()].sort();\n    const prefixes = prefixPathMethods.flatMap(method =>\n      [...this.prefixRoutes.get(method)!.keys()]\n        .sort()\n        .map(\n          pathPrefix =>\n            [\n              `${pathPrefix}*`,\n              method,\n              this.prefixRoutes.get(method)!.get(pathPrefix)!,\n            ] as const\n        )\n    );\n\n    return [...exact, ...prefixes];\n  };\n\n  /**\n   * Returns the appropriate HTTP endpoint for a request path and method.\n   *\n   * @returns - a {@link PublicHttpEndpoint} or null.\n   */\n  lookup = (\n    path: string,\n    method: RoutableMethod | \"HEAD\"\n  ): [PublicHttpEndpoint<any>, RoutableMethod, string] | null => {\n    method = normalizeMethod(method);\n    const exactMatch = this.exactRoutes.get(path)?.get(method);\n    if (exactMatch) return [exactMatch, method, path];\n\n    const prefixes = this.prefixRoutes.get(method) || new Map();\n    for (const [pathPrefix, endpoint] of prefixes.entries()) {\n      if (path.startsWith(pathPrefix)) {\n        return [endpoint, method, `${pathPrefix}*`];\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Given a JSON string representation of a Request object, return a Response\n   * by routing the request and running the appropriate endpoint or returning\n   * a 404 Response.\n   *\n   * @param argsStr - a JSON string representing a Request object.\n   *\n   * @returns - a Response object.\n   */\n  runRequest = async (argsStr: string): Promise<string> => {\n    const request = performJsSyscall(\"requestFromConvexJson\", {\n      convexJson: JSON.parse(argsStr),\n    });\n\n    const pathname = new URL(request.url).pathname;\n\n    const method = request.method;\n    const match = this.lookup(pathname, method as RoutableMethod);\n    if (!match) {\n      const response = new Response(`No HttpEndpoint routed for ${pathname}`, {\n        status: 404,\n      });\n      return JSON.stringify(\n        performJsSyscall(\"convexJsonFromResponse\", { response })\n      );\n    }\n    const [endpoint, _method, _path] = match;\n    const calls = setupHttpCalls();\n    const ctx = {\n      ...calls,\n      auth: setupAuth(),\n    };\n    const response = await (endpoint as any)(ctx, request);\n    return JSON.stringify(\n      performJsSyscall(\"convexJsonFromResponse\", { response })\n    );\n  };\n}\n"],
  "mappings": "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",
  "names": ["response"]
}
