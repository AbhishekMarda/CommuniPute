{
  "version": 3,
  "sources": ["../../../src/values/values.ts"],
  "sourcesContent": ["/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"base64-js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * **Important**: Use `myId.equals(otherId)` to check for equality.\n * Using `===` will not work because two different instances of `Id` can refer\n * to the same document.\n *\n * `Id`s are 17 bytes long and consist of:\n * - A 15-byte random value.\n * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.\n * This is encoded in base 62 ([0-9A-Za-z]).\n *\n * If you're using code generation, use the `Id` class typed for your data model in\n * `convex/_generated/dataModel.js`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport class Id<TableName extends string> {\n  /**\n   * The table name this {@link GenericId} references.\n   */\n  public readonly tableName: TableName;\n\n  /**\n   * The identifier string.\n   *\n   * This contains the characters `[0-9A-Za-z]`.\n   */\n  public readonly id: string;\n\n  constructor(tableName: TableName, id: string) {\n    this.tableName = tableName;\n    this.id = id;\n  }\n\n  /**\n   * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.\n   *\n   * @param other - The other {@link GenericId} to compare to.\n   * @returns `true` if the objects refer to the same document.\n   */\n  equals(other: unknown): boolean {\n    if (other instanceof Id) {\n      return this.tableName === other.tableName && this.id === other.id;\n    }\n    return false;\n  }\n\n  /**\n   * Parse a {@link GenericId} from its JSON representation.\n   */\n  static fromJSON(obj: any): Id<string> {\n    if (typeof obj.$id !== \"string\") {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`\n      );\n    }\n    const parts = obj.$id.split(\"|\");\n    if (parts.length !== 2) {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`\n      );\n    }\n    return new Id(parts[0], parts[1]);\n  }\n\n  /**\n   * Convert a {@link GenericId} into its JSON representation.\n   */\n  toJSON(): JSONValue {\n    const idString = `${this.tableName}|${this.id}`;\n    return { $id: idString };\n  }\n\n  /**\n   * Convert a {@link GenericId} into its string representation.\n   *\n   * This includes the identifier but not the table name.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Pretty-print this {@link GenericId} for debugging.\n   */\n  inspect(): string {\n    return `Id('${this.tableName}', '${this.id}')`;\n  }\n}\n\n/**\n * Internal type used in Convex code generation.\n *\n * @public\n */\nexport type GenericIdConstructor<TableNames extends string> = {\n  new <TableName extends TableNames>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName>;\n  prototype: Id<string>;\n  fromJSON(obj: any): Id<string>;\n};\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | Id<string>\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | Set<Value>\n  | Map<Value, Value>\n  | { [key: string]: Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 64;\nconst ALL_UNDERSCORES = /^_+$/;\nconst IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;\n\nfunction validateObjectField(k: string) {\n  if (k.length === 0) {\n    throw new Error(\"Empty field names are disallowed.\");\n  }\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  if (ALL_UNDERSCORES.test(k)) {\n    throw new Error(`Field name ${k} can't exclusively be underscores.`);\n  }\n  if (!IDENTIFIER_REGEX.test(k)) {\n    throw new Error(\n      `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`\n    );\n  }\n}\n\nfunction jsonToConvexInternal(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof Array) {\n    return value.map(jsonToConvexInternal);\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$id\" || key === \"$weakRef\" || key === \"$strongRef\") {\n      return Id.fromJSON(value);\n    }\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      if (!(value.$set instanceof Array)) {\n        throw new Error(`Malformed $set field on ${value}`);\n      }\n      return new Set(value.$set.map(jsonToConvexInternal));\n    }\n    if (key === \"$map\") {\n      if (!(value.$map instanceof Array)) {\n        throw new Error(`Malformed $map field on ${value}`);\n      }\n      const map = new Map();\n      for (const pair of value.$map) {\n        if (!(pair instanceof Array) || pair.length !== 2) {\n          throw new Error(`Malformed pair in $map ${value}`);\n        }\n        const k = jsonToConvexInternal(pair[0]);\n        const v = jsonToConvexInternal(pair[1]);\n        map.set(k, v);\n      }\n      return map;\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvexInternal(v);\n  }\n  return out;\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will revive classes like {@link GenericId} that have been serialized to JSON, parse out `BigInt`s, and so on.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  return jsonToConvexInternal(value);\n}\n\nfunction stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` will serialize `undefined` to `null` which\n      // produces a confusing error message. Use `\"undefined\"` instead.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (value instanceof Id) {\n    return value.toJSON();\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (value instanceof Array) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`)\n    );\n  }\n  if (value instanceof Set) {\n    return {\n      $set: [...value].map((value, i) =>\n        convexToJsonInternal(value, originalValue, context + `.keys()[${i}]`)\n      ),\n    };\n  }\n  if (value instanceof Map) {\n    return {\n      $map: [...value].map(([k, v], i) => {\n        const jsonKey = convexToJsonInternal(\n          k,\n          originalValue,\n          context + `.keys()[${i}]`\n        );\n        const jsonValue = convexToJsonInternal(\n          v,\n          originalValue,\n          context + `.values()[${i}]`\n        );\n        return [jsonKey, jsonValue];\n      }),\n    };\n  }\n\n  if (typeof value !== \"object\") {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype) {\n    throw new Error(\n      `${value} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);\n  }\n  return out;\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\");\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
