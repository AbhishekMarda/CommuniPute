{
  "version": 3,
  "sources": ["../../../../src/browser/sync/request_manager.ts"],
  "sourcesContent": ["import { jsonToConvex } from \"../../values/index.js\";\nimport { createError, logToConsole } from \"../logging.js\";\nimport { Long } from \"../long.js\";\nimport {\n  ClientMessage,\n  MutationRequest,\n  MutationResponse,\n  RequestId,\n} from \"./protocol.js\";\n\ntype RequestStatus =\n  | {\n      status: \"Requested\";\n      onResult: (result: any) => void;\n      onFailure: (reason: any) => void;\n    }\n  | {\n      status: \"Completed\";\n      onResolve: () => void;\n      ts: Long;\n    };\n\n// RequestManager tracks idempotent requests - Mutations.\nexport class RequestManager {\n  private inflightRequests: Map<\n    RequestId,\n    {\n      message: MutationRequest;\n      status: RequestStatus;\n    }\n  >;\n  constructor() {\n    this.inflightRequests = new Map();\n  }\n\n  request(message: MutationRequest): Promise<any> {\n    const result = new Promise((resolve, reject) => {\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: { status: \"Requested\", onResult: resolve, onFailure: reject },\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise. Only applies to mutations.\n   */\n  onResponse(response: MutationResponse): RequestId | null {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === undefined) {\n      // Annoyingly we can occasionally get responses to mutations that we're no\n      // longer tracking. One flow where this happens is:\n      // 1. Client sends mutation 1\n      // 2. Client gets response for mutation 1. The sever says that it was committed at ts=10.\n      // 3. Client is disconnected\n      // 4. Client reconnects and re-issues queries and this mutation.\n      // 5. Server sends transition message to ts=20\n      // 6. Client drops mutation because it's already been observed.\n      // 7. Client receives a second response for mutation 1 but doesn't know about it anymore.\n\n      // The right fix for this is probably to add a reconciliation phase on\n      // reconnection where we receive responses to all the mutations before\n      // the transition message so this flow could never happen (CX-1513).\n\n      // For now though, we can just ignore this message.\n      return null;\n    }\n\n    // Because `.restart()` re-requests completed requests, we may get some\n    // responses for requests that are already in the \"Completed\" state.\n    // We can safely ignore those because we've already notified the UI about\n    // their results.\n    if (requestInfo.status.status !== \"Requested\") {\n      return null;\n    }\n\n    const udfType = \"mutation\";\n    const udfPath = requestInfo.message.udfPath;\n\n    for (const line of response.logLines) {\n      logToConsole(\"info\", udfType, udfPath, line);\n    }\n\n    const status = requestInfo.status;\n    let onResolve;\n    if (response.success) {\n      onResolve = () => status.onResult(jsonToConvex(response.result));\n    } else {\n      logToConsole(\"error\", udfType, udfPath, response.result);\n      onResolve = () =>\n        status.onFailure(createError(udfType, udfPath, response.result));\n    }\n\n    if (!response.success) {\n      // We can resolve Mutation failures immediately since they don't have any\n      // side effects.\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      return response.requestId;\n    }\n\n    // We have to wait to resolve the request promise until after we transition\n    // past this timestamp so clients can read their own writes.\n    requestInfo.status = {\n      status: \"Completed\",\n      ts: response.ts,\n      onResolve,\n    };\n\n    return null;\n  }\n\n  // Removed completed requests and returns the set of completed\n  // mutations.\n  removeCompleted(ts: Long): Set<RequestId> {\n    const completeMutations: Set<RequestId> = new Set();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        if (requestInfo.message.type === \"Mutation\") {\n          completeMutations.add(requestId);\n        }\n        this.inflightRequests.delete(requestId);\n      }\n    }\n    return completeMutations;\n  }\n\n  restart(): ClientMessage[] {\n    // When we reconnect to the backend, re-request all the in-flight requests.\n\n    // This includes ones that have already been completed because we still\n    // want to tell the backend to transition the client past the completed\n    // timestamp. This is safe because mutations are idempotent.\n    const allMessages = [];\n    for (const value of this.inflightRequests.values()) {\n      allMessages.push(value.message);\n    }\n    return allMessages;\n  }\n\n  /**\n   ** @returns true if there are any requests that have been requested but have\n   ** not be completed yet.\n   **/\n  hasIncompleteRequests(): boolean {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   ** @returns true if there are any inflight requests, including ones that have\n   ** completed on the server, but have not been applied.\n   **/\n  hasInflightRequests(): boolean {\n    return this.inflightRequests.size > 0;\n  }\n}\n"],
  "mappings": ";AAAA,SAAS,oBAAoB;AAC7B,SAAS,aAAa,oBAAoB;AAsBnC,aAAM,eAAe;AAAA,EAQ1B,cAAc;AACZ,SAAK,mBAAmB,oBAAI,IAAI;AAAA,EAClC;AAAA,EAEA,QAAQ,SAAwC;AAC9C,UAAM,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC9C,WAAK,iBAAiB,IAAI,QAAQ,WAAW;AAAA,QAC3C;AAAA,QACA,QAAQ,EAAE,QAAQ,aAAa,UAAU,SAAS,WAAW,OAAO;AAAA,MACtE,CAAC;AAAA,IACH,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAQA,WAAW,UAA8C;AACvD,UAAM,cAAc,KAAK,iBAAiB,IAAI,SAAS,SAAS;AAChE,QAAI,gBAAgB,QAAW;AAgB7B,aAAO;AAAA,IACT;AAMA,QAAI,YAAY,OAAO,WAAW,aAAa;AAC7C,aAAO;AAAA,IACT;AAEA,UAAM,UAAU;AAChB,UAAM,UAAU,YAAY,QAAQ;AAEpC,eAAW,QAAQ,SAAS,UAAU;AACpC,mBAAa,QAAQ,SAAS,SAAS,IAAI;AAAA,IAC7C;AAEA,UAAM,SAAS,YAAY;AAC3B,QAAI;AACJ,QAAI,SAAS,SAAS;AACpB,kBAAY,MAAM,OAAO,SAAS,aAAa,SAAS,MAAM,CAAC;AAAA,IACjE,OAAO;AACL,mBAAa,SAAS,SAAS,SAAS,SAAS,MAAM;AACvD,kBAAY,MACV,OAAO,UAAU,YAAY,SAAS,SAAS,SAAS,MAAM,CAAC;AAAA,IACnE;AAEA,QAAI,CAAC,SAAS,SAAS;AAGrB,gBAAU;AACV,WAAK,iBAAiB,OAAO,SAAS,SAAS;AAC/C,aAAO,SAAS;AAAA,IAClB;AAIA,gBAAY,SAAS;AAAA,MACnB,QAAQ;AAAA,MACR,IAAI,SAAS;AAAA,MACb;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAIA,gBAAgB,IAA0B;AACxC,UAAM,oBAAoC,oBAAI,IAAI;AAClD,eAAW,CAAC,WAAW,WAAW,KAAK,KAAK,iBAAiB,QAAQ,GAAG;AACtE,YAAM,SAAS,YAAY;AAC3B,UAAI,OAAO,WAAW,eAAe,OAAO,GAAG,gBAAgB,EAAE,GAAG;AAClE,eAAO,UAAU;AACjB,YAAI,YAAY,QAAQ,SAAS,YAAY;AAC3C,4BAAkB,IAAI,SAAS;AAAA,QACjC;AACA,aAAK,iBAAiB,OAAO,SAAS;AAAA,MACxC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,UAA2B;AAMzB,UAAM,cAAc,CAAC;AACrB,eAAW,SAAS,KAAK,iBAAiB,OAAO,GAAG;AAClD,kBAAY,KAAK,MAAM,OAAO;AAAA,IAChC;AACA,WAAO;AAAA,EACT;AAAA,EAMA,wBAAiC;AAC/B,eAAW,eAAe,KAAK,iBAAiB,OAAO,GAAG;AACxD,UAAI,YAAY,OAAO,WAAW,aAAa;AAC7C,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAMA,sBAA+B;AAC7B,WAAO,KAAK,iBAAiB,OAAO;AAAA,EACtC;AACF;",
  "names": []
}
