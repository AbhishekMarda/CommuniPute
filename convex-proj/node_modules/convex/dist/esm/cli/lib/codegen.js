"use strict";
import esbuild from "esbuild";
import path from "path";
import prettier from "prettier";
import { mkdtemp, nodeFs } from "../../bundler/fs.js";
import { actionsDir, allEntryPoints, walkDir } from "../../bundler/index.js";
import { actionsTsconfigCodegen } from "../codegen_templates/actionsTsconfig.js";
import { apiCodegen } from "../codegen_templates/api.js";
import {
  dataModel,
  dataModelWithoutSchema
} from "../codegen_templates/dataModel.js";
import { reactCodegen } from "../codegen_templates/react.js";
import { readmeCodegen } from "../codegen_templates/readme.js";
import { serverCodegen } from "../codegen_templates/server.js";
import { tsconfigCodegen } from "../codegen_templates/tsconfig.js";
import {
  processTypeCheckResult,
  typeCheckFunctions
} from "./typecheck.js";
import { functionsDir } from "./utils.js";
function format(source, filetype) {
  return prettier.format(source, { parser: filetype });
}
function compileToCommonJS(source) {
  const { code } = esbuild.transformSync(source, {
    format: "cjs",
    target: "node14",
    minify: false
  });
  return code;
}
function writeFile(ctx, filename, source, dir, dryRun, debug, quiet, filetype = "typescript") {
  const formattedSource = format(source, filetype);
  const dest = path.join(dir.tmpPath, filename);
  if (debug) {
    console.log(`# ${filename}`);
    console.log(formattedSource);
    return;
  }
  if (dryRun) {
    if (ctx.fs.exists(dest)) {
      const fileText = ctx.fs.readUtf8File(dest);
      if (fileText !== formattedSource) {
        console.log(`Command would replace file: ${dest}`);
      }
    } else {
      console.log(`Command would create file: ${dest}`);
    }
    return;
  }
  if (!quiet) {
    console.log(`writing ${filename}`);
  }
  nodeFs.writeUtf8File(dest, formattedSource);
}
function writeJsWithTypes(ctx, name, content, codegenDir, dryRun, debug, quiet, commonjs) {
  writeFile(ctx, `${name}.d.ts`, content.DTS, codegenDir, dryRun, debug, quiet);
  if (content.JS) {
    const js = commonjs ? compileToCommonJS(content.JS) : content.JS;
    writeFile(ctx, `${name}.js`, js, codegenDir, dryRun, debug, quiet);
  }
}
function doServerCodegen(ctx, codegenDir, dryRun, hasSchemaFile, debug, quiet = false, commonjs = false) {
  if (hasSchemaFile) {
    writeJsWithTypes(
      ctx,
      "dataModel",
      dataModel,
      codegenDir,
      dryRun,
      debug,
      quiet,
      commonjs
    );
  } else {
    writeJsWithTypes(
      ctx,
      "dataModel",
      dataModelWithoutSchema,
      codegenDir,
      dryRun,
      debug,
      quiet,
      commonjs
    );
  }
  writeJsWithTypes(
    ctx,
    "server",
    serverCodegen(),
    codegenDir,
    dryRun,
    debug,
    quiet,
    commonjs
  );
}
async function doApiCodegen(ctx, functionsDir2, codegenDir, dryRun, debug, quiet = false, commonjs = false) {
  const modulePaths = (await allEntryPoints(ctx.fs, functionsDir2, false)).map(
    (entryPoint) => path.relative(functionsDir2, entryPoint)
  );
  writeJsWithTypes(
    ctx,
    "api",
    apiCodegen(modulePaths),
    codegenDir,
    dryRun,
    debug,
    quiet,
    commonjs
  );
}
async function doReactCodegen(ctx, codegenDir, dryRun, debug, quiet = false, commonjs = false) {
  writeJsWithTypes(
    ctx,
    "react",
    reactCodegen(),
    codegenDir,
    dryRun,
    debug,
    quiet,
    commonjs
  );
}
export async function doCodegen({
  ctx,
  projectConfig,
  configPath,
  typeCheckMode,
  dryRun = false,
  debug = false,
  quiet = false,
  commonjs = false
}) {
  const funcDir = functionsDir(configPath, projectConfig);
  const legacyCodegenPath = path.join(funcDir, "_generated.ts");
  if (ctx.fs.exists(legacyCodegenPath)) {
    if (!dryRun) {
      console.log(`Deleting legacy codegen file: ${legacyCodegenPath}}`);
      ctx.fs.unlink(legacyCodegenPath);
    } else {
      console.log(
        `Command would delete legacy codegen file: ${legacyCodegenPath}}`
      );
    }
  }
  ctx.fs.mkdir(funcDir, { allowExisting: true });
  const schemaPath = path.join(funcDir, "schema.ts");
  const hasSchemaFile = ctx.fs.exists(schemaPath);
  await mkdtemp("_generated", async (tempCodegenDir) => {
    doServerCodegen(
      ctx,
      tempCodegenDir,
      dryRun,
      hasSchemaFile,
      debug,
      quiet,
      commonjs
    );
    await doApiCodegen(ctx, funcDir, tempCodegenDir, dryRun, debug, quiet);
    await doReactCodegen(ctx, tempCodegenDir, dryRun, debug, quiet, commonjs);
    if (!debug && !dryRun) {
      const codegenDir = path.join(funcDir, "_generated");
      syncFromTemp(ctx, tempCodegenDir, codegenDir, true);
    }
    await processTypeCheckResult(
      ctx,
      typeCheckMode,
      () => typeCheckFunctions(ctx, funcDir)
    );
  });
}
function syncFromTemp(ctx, tempDir, destDir, eliminateExtras) {
  ctx.fs.mkdir(destDir, { allowExisting: true });
  const added = /* @__PURE__ */ new Set();
  for (const { isDir, path: fpath } of Array.from(
    walkDir(ctx.fs, tempDir.tmpPath)
  )) {
    const relPath = path.relative(tempDir.tmpPath, fpath);
    const destPath = path.join(destDir, relPath);
    if (ctx.fs.exists(destPath)) {
      if (ctx.fs.stat(destPath).isDirectory()) {
        if (!isDir) {
          ctx.fs.rm(destPath, { recursive: true });
        }
      } else {
        ctx.fs.unlink(destPath);
      }
    }
    if (isDir) {
      ctx.fs.mkdir(destPath, { allowExisting: true });
    } else {
      ctx.fs.renameFile(fpath, destPath);
    }
    added.add(destPath);
  }
  if (eliminateExtras) {
    const destEntries = Array.from(walkDir(ctx.fs, destDir)).reverse();
    for (const { isDir, path: fpath } of destEntries) {
      if (!added.has(fpath)) {
        if (isDir) {
          ctx.fs.rmdir(fpath);
        } else {
          ctx.fs.unlink(fpath);
        }
      }
    }
  }
}
export async function doInitCodegen(ctx, functionsDir2, quiet = false, dryRun = false, debug = false) {
  const actionsPath = path.join(functionsDir2, actionsDir);
  const hasActionsDir = ctx.fs.exists(actionsPath);
  await mkdtemp("convex", async (tempFunctionsDir) => {
    doReadmeCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);
    doTsconfigCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);
    if (hasActionsDir) {
      ctx.fs.mkdir(path.join(tempFunctionsDir.tmpPath, actionsDir), {
        allowExisting: true
      });
      doActionsTsconfigCodegen(ctx, tempFunctionsDir, dryRun, debug, quiet);
    }
    syncFromTemp(ctx, tempFunctionsDir, functionsDir2, false);
  });
}
function doReadmeCodegen(ctx, tempFunctionsDir, dryRun = false, debug = false, quiet = false) {
  writeFile(
    ctx,
    "README.md",
    readmeCodegen(),
    tempFunctionsDir,
    dryRun,
    debug,
    quiet,
    "markdown"
  );
}
function doTsconfigCodegen(ctx, tempFunctionsDir, dryRun = false, debug = false, quiet = false) {
  writeFile(
    ctx,
    "tsconfig.json",
    tsconfigCodegen(),
    tempFunctionsDir,
    dryRun,
    debug,
    quiet,
    "json"
  );
}
function doActionsTsconfigCodegen(ctx, tempFunctionsDir, dryRun = false, debug = false, quiet = false) {
  writeFile(
    ctx,
    path.join(actionsDir, "tsconfig.json"),
    actionsTsconfigCodegen(),
    tempFunctionsDir,
    dryRun,
    debug,
    quiet,
    "json"
  );
}
//# sourceMappingURL=codegen.js.map
