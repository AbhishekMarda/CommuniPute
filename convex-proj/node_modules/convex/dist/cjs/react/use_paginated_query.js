"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var use_paginated_query_exports = {};
__export(use_paginated_query_exports, {
  optimisticallyUpdateValueInPaginatedQuery: () => optimisticallyUpdateValueInPaginatedQuery,
  usePaginatedQueryGeneric: () => usePaginatedQueryGeneric
});
module.exports = __toCommonJS(use_paginated_query_exports);
var import_values = require("../values/index.js");
var import_react = require("react");
var import_use_queries = require("./use_queries.js");
function usePaginatedQueryGeneric(name, options, ...args) {
  const createInitialState = (0, import_react.useMemo)(() => {
    return () => {
      const id = nextPaginationId();
      return {
        name,
        args,
        id,
        maxQueryIndex: 0,
        queries: {
          0: {
            name,
            args: [
              {
                numItems: options.initialNumItems,
                cursor: null,
                id
              },
              ...args
            ]
          }
        }
      };
    };
  }, [JSON.stringify((0, import_values.convexToJson)(args)), name, options.initialNumItems]);
  const [state, setState] = (0, import_react.useState)(createInitialState);
  let currState = state;
  if (name !== state.name || JSON.stringify((0, import_values.convexToJson)(args)) !== JSON.stringify((0, import_values.convexToJson)(state.args))) {
    currState = createInitialState();
    setState(currState);
  }
  const resultsObject = (0, import_use_queries.useQueriesGeneric)(currState.queries);
  const [results, maybeLastResult] = (0, import_react.useMemo)(() => {
    let currResult = void 0;
    const allItems = [];
    for (let i = 0; i <= currState.maxQueryIndex; i++) {
      currResult = resultsObject[i];
      if (currResult === void 0) {
        break;
      }
      if (currResult instanceof Error) {
        if (currResult.message.includes("InvalidCursor") || currResult.message.includes("QueryScannedTooManyDocuments")) {
          setState(createInitialState);
          return [[], void 0];
        } else {
          throw currResult;
        }
      }
      allItems.push(...currResult.page);
    }
    return [allItems, currResult];
  }, [resultsObject, currState.maxQueryIndex, createInitialState]);
  const statusAndLoadMore = (0, import_react.useMemo)(() => {
    if (maybeLastResult === void 0) {
      return {
        status: "LoadingMore",
        loadMore: void 0
      };
    }
    if (maybeLastResult.isDone) {
      return {
        status: "Exhausted",
        loadMore: void 0
      };
    }
    const continueCursor = maybeLastResult.continueCursor;
    let alreadyLoadingMore = false;
    return {
      status: "CanLoadMore",
      loadMore: (numItems) => {
        if (!alreadyLoadingMore) {
          alreadyLoadingMore = true;
          setState((prevState) => {
            const maxQueryIndex = prevState.maxQueryIndex + 1;
            const queries = { ...prevState.queries };
            queries[maxQueryIndex] = {
              name: prevState.name,
              args: [
                { numItems, cursor: continueCursor, id: prevState.id },
                ...prevState.args
              ]
            };
            return {
              ...prevState,
              maxQueryIndex,
              queries
            };
          });
        }
      }
    };
  }, [maybeLastResult]);
  return {
    results,
    ...statusAndLoadMore
  };
}
let paginationId = 0;
function nextPaginationId() {
  paginationId++;
  return paginationId;
}
function optimisticallyUpdateValueInPaginatedQuery(localStore, name, args, updateValue) {
  const expectedArgs = JSON.stringify((0, import_values.convexToJson)(args));
  for (const query of localStore.getAllQueries(name)) {
    if (query.value !== void 0 && query.args.length >= 1 && JSON.stringify((0, import_values.convexToJson)(query.args.slice(1))) === expectedArgs) {
      const value = query.value;
      if (typeof value === "object" && value !== null && Array.isArray(value.page)) {
        localStore.setQuery(name, query.args, {
          ...value,
          page: value.page.map(updateValue)
        });
      }
    }
  }
}
//# sourceMappingURL=use_paginated_query.js.map
