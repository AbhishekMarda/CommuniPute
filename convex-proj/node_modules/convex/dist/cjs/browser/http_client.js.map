{
  "version": 3,
  "sources": ["../../../src/browser/http_client.ts"],
  "sourcesContent": ["import {\n  ActionNames,\n  GenericAPI,\n  MutationNames,\n  NamedAction,\n  NamedMutation,\n  NamedQuery,\n  QueryNames,\n} from \"../api/index.js\";\nimport { STATUS_CODE_UDF_FAILED } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport { convexToJson, jsonToConvex } from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\n\n/** In browsers, Node.js 18, Deno, etc. `fetch` is a global function */\ntype WindowFetch = typeof window.fetch;\n\nconst fetch: WindowFetch =\n  globalThis.fetch ||\n  ((...args) =>\n    import(\"node-fetch\").then(({ default: fetch }) =>\n      (fetch as unknown as WindowFetch)(...args)\n    ));\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex query function on the server.\n *\n * @public\n */\nexport interface Query<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the query on the server, returning a `Promise` of the return value.\n   *\n   * @param args - Arguments for the query.\n   * @returns The result of the query.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface Mutation<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex action on the server.\n *\n * @internal\n */\nexport interface Action<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the action on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the action.\n   * @returns The return value of the server-side action call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n *\n * @public\n */\nexport class ConvexHttpClient<API extends GenericAPI> {\n  private readonly address: string;\n  private auth?: string;\n  private debug: boolean;\n  constructor(address: string) {\n    this.address = `${address}/api`;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.auth = value;\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Construct a new {@link Query}.\n   *\n   * @param name - The name of the query function.\n   * @returns The {@link Query} object with that name.\n   */\n  query<Name extends QueryNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedQuery<API, Name>>\n    ): Promise<ReturnType<NamedQuery<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/query`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedQuery<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Mutation}.\n   *\n   * @param name - The name of the mutation function.\n   * @returns The {@link Mutation} object with that name.\n   */\n  mutation<Name extends MutationNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedMutation<API, Name>>\n    ): Promise<ReturnType<NamedMutation<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/mutation`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedMutation<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Action}.\n   *\n   * @param name - The name of the action.\n   * @returns The {@link Action} object with that name.\n   * @public\n   */\n  action<Name extends ActionNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedAction<API, Name>>\n    ): Promise<ReturnType<NamedAction<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/action`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedAction<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["fetch"]
}
