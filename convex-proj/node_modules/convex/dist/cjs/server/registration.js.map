{
  "version": 3,
  "sources": ["../../../src/server/registration.ts"],
  "sourcesContent": ["import {\n  Auth,\n  DatabaseReader,\n  DatabaseWriter,\n  StorageReader,\n  StorageWriter,\n} from \".\";\nimport {\n  ActionNames,\n  GenericAPI,\n  MutationNames,\n  NamedAction,\n  NamedMutation,\n  NamedQuery,\n  QueryNames,\n} from \"../browser\";\nimport { GenericDataModel } from \"./data_model.js\";\nimport { Scheduler } from \"./scheduler\";\n\n/**\n * A set of services for use within Convex mutation functions.\n *\n * The mutation context is passed as the first argument to any Convex mutation\n * function run on the server.\n *\n * If you're using code generation, use the `MutationCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport type MutationCtx<\n  DataModel extends GenericDataModel,\n  API extends GenericAPI\n> = {\n  db: DatabaseWriter<DataModel>;\n  auth: Auth;\n  storage: StorageWriter;\n  scheduler: Scheduler<API>;\n};\n\n/**\n * A set of services for use within Convex query functions.\n *\n * The query context is passed as the first argument to any Convex query\n * function run on the server.\n *\n * This differs from the {@link MutationCtx} because all of the services are\n * read-only.\n *\n * If you're using code generation, use the `QueryCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport type QueryCtx<DataModel extends GenericDataModel> = {\n  db: DatabaseReader<DataModel>;\n  auth: Auth;\n  storage: StorageReader;\n};\n\n/**\n * A set of services for use within Convex action.\n *\n * The context is passed as the first argument to any Convex action\n * run on the server.\n *\n * If you're using code generation, use the `ActionCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport type ActionCtx<API extends GenericAPI> = {\n  runQuery<Name extends QueryNames<API>>(\n    name: Name,\n    ...args: Parameters<NamedQuery<API, Name>>\n  ): Promise<ReturnType<NamedQuery<API, Name>>>;\n\n  runMutation<Name extends MutationNames<API>>(\n    name: Name,\n    ...args: Parameters<NamedMutation<API, Name>>\n  ): Promise<ReturnType<NamedMutation<API, Name>>>;\n\n  scheduler: Scheduler<API>;\n\n  auth: Auth;\n};\n\n/**\n * A set of services for use within Convex HTTP endpoint.\n *\n * The context is passed as the first argument to any Convex HTTP\n * endpoint run on the server.\n *\n * If you're using code generation, use the `HttpEndpointCtx` type in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @public\n */\nexport type HttpEndpointCtx<API extends GenericAPI> = {\n  runQuery<Name extends QueryNames<API>>(\n    name: Name,\n    ...args: Parameters<NamedQuery<API, Name>>\n  ): Promise<ReturnType<NamedQuery<API, Name>>>;\n\n  runMutation<Name extends MutationNames<API>>(\n    name: Name,\n    ...args: Parameters<NamedMutation<API, Name>>\n  ): Promise<ReturnType<NamedMutation<API, Name>>>;\n\n  runAction<Name extends ActionNames<API>>(\n    name: Name,\n    ...args: Parameters<NamedAction<API, Name>>\n  ): Promise<ReturnType<NamedAction<API, Name>>>;\n\n  auth: Auth;\n};\n\n/**\n * A mutation function that is part of this app's public API.\n *\n * You can create public mutations by wrapping your function in\n * {@link mutationGeneric} and exporting it.\n *\n * @public\n */\nexport type PublicMutation<\n  DataModel extends GenericDataModel,\n  API extends GenericAPI,\n  Args extends any[],\n  Output\n> = {\n  args: Args;\n  output: Output;\n\n  (ctx: MutationCtx<DataModel, API>, ...args: Args): Output;\n  isMutation: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeMutation(argsStr: string): Promise<string>;\n};\n\n/**\n * A query function that is part of this app's public API.\n *\n * You can create public queries by wrapping your function in\n * {@link queryGeneric} and exporting it.\n *\n * @public\n */\nexport type PublicQuery<\n  DataModel extends GenericDataModel,\n  Args extends any[],\n  Output\n> = {\n  args: Args;\n  output: Output;\n\n  (ctx: QueryCtx<DataModel>, ...args: Args): Output;\n  isQuery: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeQuery(argsStr: string): Promise<string>;\n};\n\n/**\n * An action that is part of this app's public API.\n *\n * You can create public action by wrapping your function in\n * {@link actionGeneric} and exporting it.\n *\n * @public\n */\nexport type PublicAction<API extends GenericAPI, Args extends any[], Output> = {\n  args: Args;\n  output: Output;\n\n  (ctx: ActionCtx<API>, ...args: Args): Output;\n  isAction: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeAction(requestId: string, argsStr: string): Promise<string>;\n};\n\n/**\n * An HTTP endpoint that is part of this app's public API.\n *\n * You can create public HTTP endpoints by wrapping your function in\n * {@link httpEndpointGeneric} and exporting it.\n *\n * @public\n */\nexport type PublicHttpEndpoint<API extends GenericAPI> = {\n  (ctx: HttpEndpointCtx<API>, request: Request): Response;\n  isHttp: true;\n  isRegistered?: true;\n\n  /** @internal */\n  invokeHttpEndpoint(argsStr: string): Promise<string>;\n};\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link mutationGeneric} a type specific to your data model.\n * @public\n */\nexport type MutationBuilder<\n  DataModel extends GenericDataModel,\n  API extends GenericAPI\n> = <Args extends any[], Output>(\n  func: (ctx: MutationCtx<DataModel, API>, ...args: Args) => Output\n) => PublicMutation<DataModel, API, Args, Output>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link queryGeneric} a type specific to your data model.\n * @public\n */\nexport type QueryBuilderForDataModel<DataModel extends GenericDataModel> = <\n  Args extends any[],\n  Output\n>(\n  func: (ctx: QueryCtx<DataModel>, ...args: Args) => Output\n) => PublicQuery<DataModel, Args, Output>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link actionGeneric} a type specific to your data model.\n * @public\n */\nexport type ActionBuilderForAPI<API extends GenericAPI> = <\n  Args extends any[],\n  Output\n>(\n  func: (ctx: ActionCtx<API>, ...args: Args) => Output\n) => PublicAction<API, Args, Output>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link httpEndpointGeneric} a type specific to your data model\n * and functions.\n * @public\n */\nexport type HttpEndpointBuilderForAPI<API extends GenericAPI> = (\n  func: (ctx: HttpEndpointCtx<API>, request: Request) => Promise<Response>\n) => PublicHttpEndpoint<API>;\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
