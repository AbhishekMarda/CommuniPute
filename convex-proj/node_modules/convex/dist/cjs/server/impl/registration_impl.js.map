{
  "version": 3,
  "sources": ["../../../../src/server/impl/registration_impl.ts"],
  "sourcesContent": ["import { GenericAPI } from \"../../api/index.js\";\nimport { convexToJson, jsonToConvex } from \"../../values/index.js\";\nimport { GenericDataModel } from \"../data_model.js\";\nimport {\n  ActionCtx,\n  HttpEndpointCtx,\n  MutationCtx,\n  PublicAction,\n  PublicHttpEndpoint,\n  PublicMutation,\n  PublicQuery,\n  QueryCtx,\n} from \"../registration.js\";\nimport { setupActionDatabaseClient } from \"./actions_impl.js\";\nimport { setupActionAuth, setupAuth } from \"./authentication_impl.js\";\nimport { setupReader, setupWriter } from \"./database_impl.js\";\nimport { setupHttpCalls } from \"./http_impl.js\";\nimport {\n  setupActionScheduler,\n  setupMutationScheduler,\n} from \"./scheduler_impl.js\";\nimport { setupStorageReader, setupStorageWriter } from \"./storage_impl.js\";\nimport { performJsSyscall } from \"./syscall.js\";\n\nasync function invokeMutation<\n  F extends (\n    ctx: MutationCtx<GenericDataModel, GenericAPI>,\n    ...args: any\n  ) => any\n>(func: F, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const mutationCtx = {\n    db: setupWriter(),\n    auth: setupAuth(),\n    storage: setupStorageWriter(),\n    scheduler: setupMutationScheduler(),\n  };\n  const result = await Promise.resolve(func(mutationCtx, ...(args as any)));\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define a mutation in this Convex app's public API.\n *\n * This function will be allowed to modify your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `mutation` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const mutationGeneric = <\n  DataModel extends GenericDataModel,\n  API extends GenericAPI,\n  Args extends any[],\n  Output\n>(\n  func: (ctx: MutationCtx<DataModel, API>, ...args: Args) => Output\n): PublicMutation<DataModel, API, Args, Output> => {\n  const m = func as unknown as PublicMutation<DataModel, API, Args, Output>;\n  // Helpful runtime check that functions are only be registered once\n  if (m.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  m.isRegistered = true;\n  m.isMutation = true;\n  m.invokeMutation = argsStr => invokeMutation(func as any, argsStr);\n  return m;\n};\n\nasync function invokeQuery<\n  F extends (ctx: QueryCtx<GenericDataModel>, ...args: any) => any\n>(func: F, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const queryCtx = {\n    db: setupReader(),\n    auth: setupAuth(),\n    storage: setupStorageReader(),\n  };\n  const result = await Promise.resolve(func(queryCtx, ...(args as any)));\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define a query in this Convex app's public API.\n *\n * This function will be allowed to read your Convex database and will be accessible from the client.\n *\n * If you're using code generation, use the `query` function in\n * `convex/_generated/server.d.ts` which is typed for your data model.\n *\n * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n * @returns The wrapped query. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const queryGeneric = <\n  DataModel extends GenericDataModel,\n  Args extends any[],\n  Output\n>(\n  func: (ctx: QueryCtx<DataModel>, ...args: Args) => Output\n): PublicQuery<DataModel, Args, Output> => {\n  const q = func as unknown as PublicQuery<DataModel, Args, Output>;\n  // Helpful runtime check that functions are only be registered once\n  if (q.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  q.isRegistered = true;\n  q.isQuery = true;\n  q.invokeQuery = argsStr => invokeQuery(func as any, argsStr);\n  return q;\n};\n\nasync function invokeAction<\n  API extends GenericAPI,\n  F extends (ctx: ActionCtx<API>, ...args: any) => any\n>(func: F, requestId: string, argsStr: string) {\n  const args = jsonToConvex(JSON.parse(argsStr));\n  const databaseClient = setupActionDatabaseClient(requestId);\n  const ctx = {\n    runQuery: databaseClient.runQuery,\n    runMutation: databaseClient.runMutation,\n    auth: setupActionAuth(requestId),\n    scheduler: setupActionScheduler(requestId),\n  };\n  const result = await Promise.resolve(func(ctx, ...(args as any)));\n  return JSON.stringify(convexToJson(result === undefined ? null : result));\n}\n\n/**\n * Define an action in this Convex app's public API.\n *\n * @param func - The function. It receives a {@link ActionCtx} as its first argument.\n * @returns The wrapped function. Include this as an `export` to name it and make it accessible.\n *\n * @public\n */\nexport const actionGeneric = <\n  API extends GenericAPI,\n  Args extends any[],\n  Output\n>(\n  func: (ctx: ActionCtx<API>, ...args: Args) => Output\n): PublicAction<API, Args, Output> => {\n  const q = func as unknown as PublicAction<API, Args, Output>;\n  // Helpful runtime check that functions are only be registered once\n  if (q.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  q.isRegistered = true;\n  q.isAction = true;\n  q.invokeAction = (requestId, argsStr) =>\n    invokeAction(func as any, requestId, argsStr);\n  return q;\n};\n\nasync function invokeHttpEndpoint<\n  API extends GenericAPI,\n  F extends (ctx: HttpEndpointCtx<API>, request: Request) => any\n>(func: F, argsStr: string) {\n  const calls = setupHttpCalls();\n  const ctx = {\n    ...calls,\n    auth: setupAuth(),\n  };\n  const request = performJsSyscall(\"requestFromConvexJson\", {\n    convexJson: JSON.parse(argsStr),\n  });\n  const response: any = await Promise.resolve(func(ctx, request));\n  return JSON.stringify(\n    performJsSyscall(\"convexJsonFromResponse\", { response })\n  );\n}\n\n/**\n * Define a Convex HTTP endpoint.\n *\n * @param func - The function. It receives an {@link HttpEndpointCtx} as its first argument, and a `Request` object\n * as its second.\n * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.\n *\n * @public\n */\nexport const httpEndpointGeneric = <API extends GenericAPI>(\n  func: (ctx: HttpEndpointCtx<API>, request: Request) => Promise<Response>\n): PublicHttpEndpoint<API> => {\n  const q = func as unknown as PublicHttpEndpoint<API>;\n  // Helpful runtime check that functions are only be registered once\n  if (q.isRegistered) {\n    throw new Error(\"Function registered twice \" + func);\n  }\n  q.isRegistered = true;\n  q.isHttp = true;\n  q.invokeHttpEndpoint = argsStr => invokeHttpEndpoint(func as any, argsStr);\n  return q;\n};\n"],
  "mappings": "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",
  "names": []
}
